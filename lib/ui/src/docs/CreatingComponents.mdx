{/* CreatingComponents.mdx */}
import { Meta } from '@storybook/blocks';

<Meta title="Guidelines/Creating Components" />

# Creating Components

A comprehensive guide to building components for the Zen Design System. Follow these
patterns to ensure consistency, maintainability, and a great developer experience.

export const FileCard = ({ name, description }) => (
  <div
    style={{
      display: 'flex',
      alignItems: 'flex-start',
      gap: '1rem',
      padding: '1rem',
      backgroundColor: 'var(--color-surface)',
      border: '1px solid var(--color-border-subtle)',
      borderRadius: 'var(--radius-md)',
      marginBottom: '0.5rem',
    }}
  >
    <code
      style={{
        padding: '0.25rem 0.5rem',
        backgroundColor: 'var(--color-primary-subtle)',
        color: 'var(--color-primary)',
        borderRadius: 'var(--radius-sm)',
        fontFamily: 'var(--font-family-mono)',
        fontSize: 'var(--font-size-sm)',
        whiteSpace: 'nowrap',
      }}
    >
      {name}
    </code>
    <span
      style={{
        fontSize: 'var(--font-size-sm)',
        color: 'var(--color-text-secondary)',
        lineHeight: 'var(--line-height-body)',
      }}
    >
      {description}
    </span>
  </div>
)

export const Guideline = ({ type, children }) => {
  const colors = {
    do: {
      bg: 'var(--color-secondary-50)',
      border: 'var(--color-secondary-500)',
      label: '✓ Do',
    },
    dont: { bg: '#fef2f2', border: '#ef4444', label: "✗ Don't" },
  }
  const style = colors[type]
  return (
    <div
      style={{
        padding: '1rem',
        backgroundColor: style.bg,
        borderLeft: `4px solid ${style.border}`,
        borderRadius: 'var(--radius-md)',
        marginBottom: '0.75rem',
      }}
    >
      <div
        style={{
          fontWeight: 'var(--font-weight-semibold)',
          fontSize: 'var(--font-size-sm)',
          color: style.border,
          marginBottom: '0.5rem',
        }}
      >
        {style.label}
      </div>
      <div
        style={{
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-primary)',
        }}
      >
        {children}
      </div>
    </div>
  )
}

---

## File Structure

Each component should live in its own folder within `src/components/` with the
following structure:

<FileCard
  name="ComponentName.tsx"
  description="The main component implementation with TypeScript types and props interface."
/>
<FileCard
  name="ComponentName.css"
  description="Component-specific base styles using CSS custom properties from design tokens. Responsive styles are handled with Emotion."
/>
<FileCard
  name="ComponentName.stories.tsx"
  description="Storybook stories showcasing all variants, sizes, and states."
/>
<FileCard
  name="ComponentName.test.tsx"
  description="Component tests using Vitest and React Testing Library (optional but recommended)."
/>
<FileCard
  name="{ComponentName}Constants.ts"
  description="Typed constants for CSS custom property names (optional, for complex components)."
/>
<FileCard name="index.ts" description="Barrel export file for clean imports." />

### Example Structure

**Basic component:**

```
src/components/
└── ComponentName/
    ├── ComponentName.tsx
    ├── ComponentName.css
    ├── ComponentName.stories.tsx
    ├── ComponentName.test.tsx
    └── index.ts
```

**Component with constants:**

```
src/components/
└── ComponentName/
    ├── ComponentName.tsx
    ├── ComponentName.css
    ├── ComponentName.stories.tsx
    ├── ComponentName.test.tsx
    ├── {ComponentName}Constants.ts
    └── index.ts
```

**Note:** For compound components with sub-components, extract sub-components to separate files when they become complex:

```
src/components/
└── ComponentName/
    ├── ComponentName.tsx      # Main component
    ├── ComponentNameSub.tsx    # Sub-component (e.g., GridCell)
    ├── ComponentName.css
    ├── ComponentName.stories.tsx
    ├── ComponentName.test.tsx
    ├── {ComponentName}Constants.ts  # Optional
    └── index.ts               # Exports both components
```

---

## YAGNI Principle

**You Ain't Gonna Need It** — build only what is explicitly required.

The Zen Design System follows a minimal implementation philosophy. Before adding any feature or prop, ask yourself: "Is this explicitly requested or documented in the requirements?"

<div
  style={{
    padding: '1.5rem',
    backgroundColor: 'var(--color-surface)',
    border: '1px solid var(--color-border-subtle)',
    borderRadius: 'var(--radius-md)',
    marginBottom: '1.5rem',
  }}
>
  <h4
    style={{
      margin: '0 0 1rem 0',
      fontSize: 'var(--font-size-base)',
      fontWeight: 'var(--font-weight-semibold)',
      color: 'var(--color-text-primary)',
    }}
  >
    YAGNI Guidelines
  </h4>
  <ul
    style={{
      margin: 0,
      paddingLeft: '1.25rem',
      fontSize: 'var(--font-size-sm)',
      color: 'var(--color-text-secondary)',
      lineHeight: '1.8',
    }}
  >
    <li>Only add props or functionality that is explicitly requested</li>
    <li>Avoid speculative features ("this might be useful someday")</li>
    <li>Start with the minimal viable implementation</li>
    <li>Add complexity only when real use cases demand it</li>
    <li>Prefer composition over configuration</li>
  </ul>
</div>

<Guideline type="do">
  Build the exact feature requested. If a Button is needed with primary and
  secondary variants, implement only those two variants.
</Guideline>

<Guideline type="dont">
  Add extra variants, sizes, or props "just in case" — you can always add them
  later when a real need arises.
</Guideline>

---

## Accessibility

Building accessible components is essential for the Zen Design System. Every component must be usable by everyone, including people who rely on assistive technologies.

### Focus Management

- All interactive elements must be focusable
- Use `:focus-visible` for keyboard focus states (not `:focus`)
- Ensure focus order follows a logical reading sequence
- Trap focus within modals and dialogs when open

```css
.zen-component:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--color-focus-ring);
}
```

### Keyboard Navigation

- Support expected keyboard interactions for each component type
- Buttons: `Enter` and `Space` to activate
- Menus: Arrow keys to navigate, `Escape` to close
- Tabs: Arrow keys to switch, `Tab` to move focus
- Document all keyboard shortcuts in stories

### ARIA Attributes

Use ARIA attributes to enhance semantic meaning:

```tsx
// Button with loading state
<button aria-busy={loading} aria-disabled={disabled}>
  {loading ? 'Loading...' : children}
</button>

// Expandable section
<button aria-expanded={isOpen} aria-controls="panel-id">
  Toggle Panel
</button>
```

### Color Contrast

- Text must meet WCAG 2.1 AA contrast ratios (4.5:1 for normal text, 3:1 for large text)
- Use design tokens that have been verified for accessibility
- Never rely on color alone to convey information

### Testing with a11y Addon

The Storybook a11y addon is configured to automatically audit components. Check the "Accessibility" tab in Storybook to verify your component passes all checks:

- No violations should appear in the accessibility panel
- Test with keyboard-only navigation
- Verify screen reader announcements are meaningful

---

## Component Implementation

### TypeScript & Props

Define explicit types for all prop options using union types, and create a dedicated
props interface that extends native HTML attributes.

```tsx
import { HTMLAttributes, forwardRef } from 'react'
import './ComponentName.css'

export type ComponentVariant = 'primary' | 'secondary' | 'outline'
export type ComponentSize = 'sm' | 'md' | 'lg'

export interface ComponentNameProps extends HTMLAttributes<HTMLDivElement> {
  /** The visual style variant */
  variant?: ComponentVariant
  /** The size of the component */
  size?: ComponentSize
}
```

### Using forwardRef

Always use `forwardRef` to allow consumers to access the underlying DOM element:

```tsx
export const ComponentName = forwardRef<HTMLDivElement, ComponentNameProps>(
  (
    { variant = 'primary', size = 'md', className = '', children, ...props },
    ref,
  ) => {
    // Implementation
  },
)

ComponentName.displayName = 'ComponentName'
```

### CSS Class Construction

Build class names systematically using a consistent pattern:

```tsx
const classNames = [
  'zen-component',
  `zen-component--${variant}`,
  `zen-component--${size}`,
  className,
]
  .filter(Boolean)
  .join(' ')
```

---

## Naming Conventions

### Props

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
    gap: '1rem',
    marginBottom: '1.5rem',
  }}
>
  <div>
    <Guideline type="do">
      Use `variant` for visual style options (primary, secondary, outline,
      ghost)
    </Guideline>
    <Guideline type="do">
      Use `size` for dimension options (sm, md, lg)
    </Guideline>
    <Guideline type="do">
      Use boolean props for binary states: `disabled`, `loading`, `selected`
    </Guideline>
    <Guideline type="do">
      Use JSDoc comments with `/** */` to document each prop
    </Guideline>
  </div>
  <div>
    <Guideline type="dont">
      Use `type` or `style` for variants (conflicts with native attributes)
    </Guideline>
    <Guideline type="dont">Abbreviate prop names: `var`, `sz`, `dis`</Guideline>
    <Guideline type="dont">
      Use negative booleans: `notDisabled`, `isNotLoading`
    </Guideline>
    <Guideline type="dont">Create props for single-use edge cases</Guideline>
  </div>
</div>

### Common Prop Patterns

<table
  style={{
    width: '100%',
    borderCollapse: 'collapse',
    fontSize: 'var(--font-size-sm)',
  }}
>
  <thead>
    <tr style={{ borderBottom: '2px solid var(--color-border)' }}>
      <th
        style={{
          textAlign: 'left',
          padding: '0.75rem',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Prop
      </th>
      <th
        style={{
          textAlign: 'left',
          padding: '0.75rem',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Type
      </th>
      <th
        style={{
          textAlign: 'left',
          padding: '0.75rem',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Purpose
      </th>
    </tr>
  </thead>
  <tbody>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>variant</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Union type
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Visual style (primary, secondary, outline, ghost)
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>size</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>'sm' | 'md' | 'lg'</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Component dimensions
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>disabled</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Disables interaction
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>loading</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Shows loading state
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>selected</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Indicates selection
      </td>
    </tr>
    <tr>
      <td style={{ padding: '0.75rem' }}>
        <code>fullWidth</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Expands to container width
      </td>
    </tr>
  </tbody>
</table>

### CSS Classes

- **Prefix all classes** with `zen-` to prevent collisions
- Use **BEM-style modifiers** with double dashes: `zen-component--variant`
- Keep class names **lowercase with hyphens**: `zen-card-header`

```css
.zen-component {
  /* Base styles */
}
.zen-component--primary {
  /* Variant styles */
}
.zen-component--sm {
  /* Size styles */
}
```

---

## Styling Guidelines

### Use Design Tokens

Always use CSS custom properties from the design system. Never use hardcoded values.

<Guideline type="do">

```css
.zen-component {
  padding: var(--space-3) var(--space-4);
  font-size: var(--font-size-base);
  border-radius: var(--radius-md);
  color: var(--color-text-primary);
}
```

</Guideline>

<Guideline type="dont">

```css
.zen-component {
  padding: 12px 16px;
  font-size: 16px;
  border-radius: 8px;
  color: #333333;
}
```

</Guideline>

### CSS File Organization

Structure your CSS file with clear sections:

```css
/* ============================================
   COMPONENT NAME
   ============================================ */

.zen-component {
  /* Reset */
  /* Layout */
  /* Typography */
  /* Shape */
  /* Interaction */
}

/* ----------------------------------------
   SIZE VARIANTS
   ---------------------------------------- */

.zen-component--sm {
}
.zen-component--md {
}
.zen-component--lg {
}

/* ----------------------------------------
   STYLE VARIANTS
   ---------------------------------------- */

.zen-component--primary {
}
.zen-component--secondary {
}
```

### Component-Level CSS Variables

Define component-specific CSS custom properties to enable easy customization and maintain consistency across size variants:

```css
.zen-button--md {
  --button-height: 2.5rem;
  --button-padding-x: var(--space-4);
  --button-font-size: var(--font-size-base);

  height: var(--button-height);
  padding: 0 var(--button-padding-x);
  font-size: var(--button-font-size);
}
```

This pattern allows consumers to override specific values without modifying the base styles, and makes the relationship between size variants explicit and maintainable.

<Guideline type="do">
  Define component-level variables for dimensions, spacing, and typography that
  vary by size or variant.
</Guideline>

<Guideline type="do">
  Prefer dedicated CSS custom properties over `calc()` expressions for variant
  values. Instead of `calc(var(--base-width) + 1px)`, define `--base-width-md`
  directly.
</Guideline>

<Guideline type="dont">
  Use magic numbers directly in property values — always reference a design
  token or component variable.
</Guideline>

<Guideline type="dont">
  Use `calc()` expressions for simple size variations — define separate custom
  properties for each variant size.
</Guideline>

### Styling with Emotion

All components in the Zen Design System use Emotion for handling responsive styles. Emotion generates CSS-in-JS at runtime, automatically creating media queries for responsive props. Base component styles are still defined in CSS files (`.css`), while responsive behavior is handled through Emotion.

**Required Emotion Features:**

1. **Responsive Styles Utility** - Use the `responsiveStyles` utility to automatically generate Emotion CSS with media queries for responsive props:

```tsx
import { css } from '@emotion/react'
import { responsiveStyles } from '../../utils/responsiveStyles'

// Convert prop values to CSS strings
function gapToCSS(gap: ComponentGap): string {
  const mapping: Record<ComponentGap, string> = {
    none: '0',
    sm: 'var(--space-2)',
    md: 'var(--space-4)',
  }
  return mapping[gap]
}

// In your component:
const gapStyles = responsiveStyles('gap', gap, gapToCSS)
const paddingStyles = responsiveStyles('padding', padding, paddingToCSS)

// Combine all Emotion styles
const emotionStyles = css`
  ${gapStyles}
  ${paddingStyles}
`

// Apply to element
<div css={emotionStyles} className="zen-component">
  {children}
</div>
```

The `responsiveStyles` utility automatically generates:

- Base styles (no media query) for simple values or `base` breakpoint
- Media queries for each breakpoint (xs, sm, md, lg) when using responsive objects
- Proper CSS with media queries that Emotion injects at runtime

2. **CSS Files for Base Styles** - Use CSS files (`.css`) for non-responsive base styles, variants, and states:

```css
/* ComponentName.css */
.zen-component {
  /* Base styles */
  display: flex;
  align-items: center;
}

.zen-component:hover {
  /* Hover styles */
}

.zen-component--variant {
  /* Variant styles */
}
```

3. **Combining CSS Classes and Emotion** - Use CSS classes for non-responsive styles and Emotion for responsive behavior:

```tsx
// Build class names for non-responsive usage (backward compatibility)
const classNames = [
  'zen-component',
  variant && `zen-component--${variant}`,
  className,
]
  .filter(Boolean)
  .join(' ')

// Generate Emotion styles for responsive props
const gapStyles = responsiveStyles('gap', gap, gapToCSS)
const emotionStyles = css`${gapStyles}`

// Apply both
<div className={classNames} css={emotionStyles}>
  {children}
</div>
```

**When to Use Emotion vs CSS:**

**Use Emotion (`responsiveStyles`)** for all responsive props:

```tsx
/* ✅ Use Emotion - automatically generates media queries */
const gapStyles = responsiveStyles('gap', gap, gapToCSS)
const paddingStyles = responsiveStyles('padding', padding, paddingToCSS)
const emotionStyles = css`
  ${gapStyles} ${paddingStyles}
`
```

**Use CSS files** for:

- Non-responsive base component styles
- Variant styles (primary, secondary, etc.)
- Interactive states (hover, focus, disabled)
- Static layout and typography

**Example: Handling Multiple Responsive Props:**

```tsx
import { css } from '@emotion/react'
import { responsiveStyles } from '../../utils/responsiveStyles'

export const Component = forwardRef<HTMLDivElement, ComponentProps>(
  ({ gap, padding, gridTemplateAreas, className = '', ...props }, ref) => {
    // Generate Emotion styles for each responsive prop
    const gapStyles = responsiveStyles('gap', gap, gapToCSS)
    const paddingStyles = responsiveStyles('padding', padding, paddingToCSS)

    // For camelCase props, use the CSS property name directly
    const gridTemplateAreasStyles = responsiveStyles(
      'gridTemplateAreas',
      gridTemplateAreas,
      (val) => val, // Already a CSS value
    )

    // Combine all Emotion styles
    const emotionStyles = css`
      ${gapStyles}
      ${paddingStyles}
      ${gridTemplateAreasStyles}
    `

    // Build class names for non-responsive usage
    const classNames = ['zen-component', className].filter(Boolean).join(' ')

    return (
      <div ref={ref} className={classNames} css={emotionStyles} {...props}>
        {children}
      </div>
    )
  },
)
```

**File Organization:**

Structure your component files:

```
ComponentName/
├── ComponentName.tsx    # Component with Emotion styles
├── ComponentName.css    # Base styles, variants, states
├── ComponentName.stories.tsx
└── index.ts
```

**Component Implementation Pattern:**

```tsx
// ComponentName.tsx
import { css } from '@emotion/react'
import { responsiveStyles } from '../../utils/responsiveStyles'
import './ComponentName.css'

export const ComponentName = forwardRef<HTMLDivElement, ComponentNameProps>(
  ({ gap, padding, className = '', ...props }, ref) => {
    // Generate responsive styles with Emotion
    const gapStyles = responsiveStyles('gap', gap, gapToCSS)
    const paddingStyles = responsiveStyles('padding', padding, paddingToCSS)

    const emotionStyles = css`
      ${gapStyles}
      ${paddingStyles}
    `

    const classNames = ['zen-component', className].filter(Boolean).join(' ')

    return (
      <div ref={ref} className={classNames} css={emotionStyles} {...props}>
        {children}
      </div>
    )
  },
)
```

```css
/* ComponentName.css */
.zen-component {
  /* Base styles */
}

.zen-component--primary {
  /* Variant styles */
}

.zen-component--secondary {
  /* Variant styles */
}
```

Emotion automatically handles:

- Media query generation for responsive breakpoints
- Runtime CSS injection
- Proper CSS specificity

### CSS Custom Property Naming Conventions

CSS custom properties follow a consistent naming pattern:

**Pattern:**

```
--{componentName}-{propName}-{breakpoint}
```

**Examples:**

- `--box-padding-base` (component: box, prop: padding, breakpoint: base)
- `--flex-gap-sm` (component: flex, prop: gap, breakpoint: sm)
- `--grid-columns-lg` (component: grid, prop: columns, breakpoint: lg)

**Rules:**

- Component name: lowercase, no hyphens (e.g., `box`, `flex`, `grid`)
- Prop name: matches the prop name exactly (camelCase preserved for camelCase props)
- Breakpoint: one of `base`, `xs`, `sm`, `md`, `lg`

**For camelCase props:**

- CSS custom property keeps camelCase: `--component-gridTemplateAreas-base`
- Data attribute uses kebab-case: `data-has-responsive-grid-template-areas`

### Data Attributes for Conditional CSS

Data attributes enable CSS rules to apply only when responsive props are actually used:

```css
/* Only applies when responsive padding is used */
.zen-component[data-has-responsive-padding='true'] {
  padding: var(--component-padding-base);
}
```

**Why this matters:**

- Prevents undefined CSS variable warnings
- Only applies responsive styles when needed
- Allows CSS to work with both simple and responsive prop values

**Pattern:**

```scss
@use '../../styles/variables/breakpoints' as bp;
@use 'sass:map';

/* Base rule - only applies with data attribute */
.zen-component[data-has-responsive-{prop-name}='true'] {
  {css-property}: var(--{component-name}-{prop-name}-base);
}

/* Media queries - only apply with data attribute */
@media (min-width: map.get(bp.$breakpoints, 'sm')) {
  /* --breakpoint-sm: 640px */
  .zen-component[data-has-responsive-{prop-name}='true'] {
    {css-property}: var(
      --{component-name}-{prop-name}-sm,
      var(--{component-name}-{prop-name}-base)
    );
  }
}
```

### Fallback Chains in CSS

CSS custom properties use nested `var()` functions to create fallback chains that inherit from smaller breakpoints:

```css
/* At sm breakpoint, try sm first, then xs, then base */
padding: var(
  --component-padding-sm,
  var(--component-padding-xs, var(--component-padding-base))
);
```

**How fallback chains work:**

1. Browser tries the first value (`--component-padding-sm`)
2. If undefined, falls back to the second value (`--component-padding-xs`)
3. If still undefined, falls back to the third value (`--component-padding-base`)

**Pattern for each breakpoint:**

- **base**: `var(--component-prop-base)`
- **xs**: `var(--component-prop-xs, var(--component-prop-base))`
- **sm**: `var(--component-prop-sm, var(--component-prop-xs, var(--component-prop-base)))`
- **md**: `var(--component-prop-md, var(--component-prop-sm, var(--component-prop-xs, var(--component-prop-base))))`
- **lg**: `var(--component-prop-lg, var(--component-prop-md, var(--component-prop-sm, var(--component-prop-xs, var(--component-prop-base)))))`

This ensures that if a breakpoint value isn't set, it inherits from the previous breakpoint.

### Interactive States

Always define states in this order:

1. Base styles
2. `:hover:not(:disabled)`
3. `:focus-visible`
4. `:active:not(:disabled)`
5. `:disabled`

```css
.zen-component {
  transition: background-color var(--transition-fast), color var(--transition-fast),
    border-color var(--transition-fast);
}

.zen-component:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--color-focus-ring);
}

.zen-component:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}
```

---

## Constants Handling

For components with multiple responsive props or complex CSS custom property usage, create a constants file to provide type safety and prevent typos.

### When to Create Constants

Create a constants file when:

- Your component has many responsive props (3+)
- You reference CSS custom properties in multiple places (component, tests, stories)
- You want type safety when referencing CSS variable names
- You have complex prop names that are easy to mistype

**Simple components** may not need a constants file. Use constants when they add value.

### Constants File Structure

Create a `{ComponentName}Constants.ts` file in your component directory (e.g., `ShojiGridConstants.ts` or `shojiGridConstants.ts`):

```tsx
/**
 * Typed constants for {ComponentName} CSS custom property names
 * These constants prevent typos and provide type safety when referencing CSS variables
 */

// Padding constants
export const {COMPONENT_NAME}_PADDING_BASE = '--{componentName}-padding-base'
export const {COMPONENT_NAME}_PADDING_XS = '--{componentName}-padding-xs'
export const {COMPONENT_NAME}_PADDING_SM = '--{componentName}-padding-sm'
export const {COMPONENT_NAME}_PADDING_MD = '--{componentName}-padding-md'
export const {COMPONENT_NAME}_PADDING_LG = '--{componentName}-padding-lg'

// Gap constants
export const {COMPONENT_NAME}_GAP_BASE = '--{componentName}-gap-base'
export const {COMPONENT_NAME}_GAP_XS = '--{componentName}-gap-xs'
export const {COMPONENT_NAME}_GAP_SM = '--{componentName}-gap-sm'
export const {COMPONENT_NAME}_GAP_MD = '--{componentName}-gap-md'
export const {COMPONENT_NAME}_GAP_LG = '--{componentName}-gap-lg'

// For camelCase prop names, keep camelCase in constant name
export const {COMPONENT_NAME}_GRID_TEMPLATE_AREAS_BASE =
  '--{componentName}-gridTemplateAreas-base'
export const {COMPONENT_NAME}_GRID_TEMPLATE_AREAS_XS =
  '--{componentName}-gridTemplateAreas-xs'
export const {COMPONENT_NAME}_GRID_TEMPLATE_AREAS_SM =
  '--{componentName}-gridTemplateAreas-sm'
export const {COMPONENT_NAME}_GRID_TEMPLATE_AREAS_MD =
  '--{componentName}-gridTemplateAreas-md'
export const {COMPONENT_NAME}_GRID_TEMPLATE_AREAS_LG =
  '--{componentName}-gridTemplateAreas-lg'
```

### Naming Conventions

**Constant names:**

- Use `UPPER_SNAKE_CASE`
- Prefix with component name in uppercase with underscores: `{COMPONENT_NAME}_` (e.g., `SHOJI_GRID_`, `BOX_`, `FLEX_`)
- Use descriptive prop name: `PADDING`, `GAP`, `GRID_TEMPLATE_AREAS`
- Include breakpoint: `BASE`, `XS`, `SM`, `MD`, `LG`

**Examples:**

- `{COMPONENT_NAME}_PADDING_BASE` → `'--{componentName}-padding-base'` (e.g., `SHOJI_GRID_COLUMNS_BASE` → `'--shoji-grid-columns-base'`)
- `{COMPONENT_NAME}_GAP_MD` → `'--{componentName}-gap-md'` (e.g., `SHOJI_GRID_GAP_MD` → `'--shoji-grid-gap-md'`)
- `{COMPONENT_NAME}_GRID_TEMPLATE_AREAS_SM` → `'--{componentName}-gridTemplateAreas-sm'` (e.g., `SHOJI_GRID_GRID_TEMPLATE_AREAS_SM` → `'--shoji-grid-gridTemplateAreas-sm'`)

### Using Constants

**In component files:**

```tsx
import { {COMPONENT_NAME}_PADDING_BASE, {COMPONENT_NAME}_GAP_MD } from './{ComponentName}Constants'

// Use constants when you need to reference CSS custom properties
const basePadding = getComputedStyle(element).getPropertyValue(
  {COMPONENT_NAME}_PADDING_BASE,
)
```

**In test files:**

```tsx
import { {COMPONENT_NAME}_PADDING_BASE, {COMPONENT_NAME}_GAP_MD } from './{ComponentName}Constants'

it('should set correct CSS custom properties', () => {
  const { container } = render(
    <ComponentName padding={{ base: 'sm', md: 'lg' }} />,
  )
  const element = container.querySelector('.zen-component') as HTMLElement

  const baseValue = getComputedStyle(element).getPropertyValue(
    {COMPONENT_NAME}_PADDING_BASE,
  )
  expect(baseValue.trim()).toBe('var(--space-2)')
})
```

**In CSS/SCSS files:**

Constants are TypeScript-only. In CSS, use the string values directly:

```css
/* With Emotion, you typically don't need CSS custom properties in CSS files */
/* Emotion handles responsive styles automatically */
.zen-component {
  /* Base styles only */
}
```

### Benefits

**Type Safety:**

- TypeScript will catch typos at compile time
- IDE autocomplete helps find the right constant
- Refactoring is safer (rename constant, not strings)

**Maintainability:**

- Single source of truth for CSS custom property names
- Easy to find all usages of a CSS variable
- Clear documentation of which CSS variables exist

**Example without constants (error-prone):**

```tsx
// Easy to make typos
const value = getComputedStyle(el).getPropertyValue('--component-paddng-base') // typo!
```

**Example with constants (type-safe):**

```tsx
// TypeScript catches the error
const value = getComputedStyle(el).getPropertyValue(COMPONENT_PADDNG_BASE) // Error: doesn't exist
```

### Integration with Responsive Props

Constants work seamlessly with responsive props. With Emotion, CSS custom properties are generated internally by Emotion, but constants can still be useful for testing and accessing computed styles:

```tsx
// Emotion generates CSS with media queries automatically
const paddingStyles = responsiveStyles('padding', padding, paddingToCSS)
const emotionStyles = css`${paddingStyles}`

// Constants provide type-safe access to computed styles in tests:
import { {COMPONENT_NAME}_PADDING_BASE } from './{ComponentName}Constants'
const value = getComputedStyle(element).getPropertyValue({COMPONENT_NAME}_PADDING_BASE)
```

**Note:** With Emotion, you typically don't need to reference CSS custom properties directly in component code, as Emotion handles everything. Constants are most useful for testing scenarios.

---

## Responsive Props

All visual props in Zen Design should be responsive, allowing them to accept different values at different breakpoints. This enables components to adapt seamlessly to different screen sizes without writing custom CSS.

### Understanding Responsive Props

Every prop type `T` can be extended to accept `T | { base?: T, xs?: T, sm?: T, md?: T, lg?: T }`:

```tsx
// Simple value (applies to all breakpoints)
<Box padding="md" />

// Responsive object (different values per breakpoint)
<Box padding={{ base: 'xs', sm: 'md', lg: 'xl' }} />
```

See the [Breakpoints documentation](/docs/foundations-breakpoints--docs) for complete details on the breakpoint system.

### Making Props Responsive

All visual props should use the `Responsive<T>` type to support responsive values:

```tsx
import type { Responsive } from '../../utils/Responsive'

export interface ComponentNameProps extends HTMLAttributes<HTMLDivElement> {
  /** Padding that adapts to screen size */
  padding?: Responsive<'xs' | 'sm' | 'md' | 'lg' | 'xl'>
  /** Gap between items */
  gap?: Responsive<string>
}
```

### Implementation Pattern

Follow this pattern to implement responsive props:

#### 1. Import Required Utilities

```tsx
import { css } from '@emotion/react'
import type { Responsive, ResponsiveObject } from '../../utils/Responsive'
import { isResponsiveObject } from '../../utils/Responsive'
import { responsiveStyles } from '../../utils/responsiveStyles'
```

#### 2. Create Conversion Function (if needed)

If your prop accepts a union type that needs conversion to CSS values, create a function that converts a single value to its CSS representation:

```tsx
type ComponentGap = 'none' | 'xs' | 'sm' | 'md' | 'lg'

// Create a function that converts a single value to CSS
function gapToCSS(gap: ComponentGap): string {
  const mapping: Record<ComponentGap, string> = {
    none: '0',
    xs: 'var(--space-1)',
    sm: 'var(--space-2)',
    md: 'var(--space-4)',
    lg: 'var(--space-6)',
  }
  return mapping[gap]
}

// Use it directly with responsiveStyles
const gapStyles = responsiveStyles('gap', gap, gapToCSS)
```

**When to create a conversion function:**

- **Create a conversion function** when your prop accepts semantic values (like `'sm'`, `'md'`, `'lg'`) that need to be converted to CSS values (like `'var(--space-2)'`)
- **Skip conversion** when your prop already accepts CSS values directly (like `string` for `gridTemplateRows`) - just pass `(val) => val` as the conversion function

**Example without normalization (direct CSS values):**

```tsx
// For props that accept CSS values directly, no normalization needed
export interface ComponentNameProps {
  gridTemplateRows?: Responsive<string> // Already a CSS value
}

// In component:
const gridTemplateRowsStyles = responsiveStyles(
  'gridTemplateRows',
  gridTemplateRows,
  (val) => val, // Already a CSS value, pass through
)
const emotionStyles = css`
  ${gridTemplateRowsStyles}
`
```

**Example with normalization (semantic values):**

```tsx
// For props that accept semantic values, use the conversion function directly
export interface ComponentNameProps {
  gap?: Responsive<'none' | 'sm' | 'md'> // Semantic values
}

// In component:
const gapStyles = responsiveStyles('gap', gap, gapToCSS)
const emotionStyles = css`
  ${gapStyles}
`
```

#### 3. Generate Emotion Styles

In your component, generate Emotion styles for responsive props:

```tsx
export const ComponentName = forwardRef<HTMLDivElement, ComponentNameProps>(
  (
    {
      padding,
      gap,
      gridTemplateAreas,
      className = '',
      style,
      children,
      ...props
    },
    ref,
  ) => {
    // Generate Emotion styles for each responsive prop
    const gapStyles = responsiveStyles('gap', gap, gapToCSS)
    const paddingStyles = responsiveStyles('padding', padding, paddingToCSS)

    // For camelCase prop names, use the CSS property name directly
    const gridTemplateAreasStyles = responsiveStyles(
      'gridTemplateAreas',
      gridTemplateAreas,
      (val) => val, // Already a CSS value
    )

    // Combine all Emotion styles
    const emotionStyles = css`
      ${gapStyles}
      ${paddingStyles}
      ${gridTemplateAreasStyles}
    `

    // Build class names for non-responsive usage (backward compatibility)
    const classNames = ['zen-component', className].filter(Boolean).join(' ')

    return (
      <div
        ref={ref}
        className={classNames}
        css={emotionStyles}
        style={style}
        {...props}
      >
        {children}
      </div>
    )
  },
)
```

**Handling camelCase prop names:**

When your prop name is camelCase (like `gridTemplateAreas`), use the camelCase CSS property name directly in `responsiveStyles`:

```tsx
// Use camelCase CSS property name directly
const gridTemplateAreasStyles = responsiveStyles(
  'gridTemplateAreas', // CSS property name (camelCase)
  gridTemplateAreas,
  (val) => val,
)
```

Emotion automatically handles the CSS property name conversion and generates the appropriate media queries.

#### 3.5. Custom Conversion Functions for Special Props

Sometimes a prop needs special handling beyond a simple mapping. For example, a `columns` prop that accepts both numbers and special values like `'auto-fill'` or `'auto-fit'` may need custom conversion logic.

**When to create a custom conversion function:**

- Your prop accepts multiple types that need different conversion logic (e.g., `number | 'auto-fill' | 'auto-fit'`)
- The conversion logic is more complex than a simple mapping
- You need to transform the value before it's used in CSS

**Example: Custom conversion for columns prop**

```tsx
type ComponentColumns = number | 'auto-fill' | 'auto-fit'

/**
 * Convert ComponentColumns to grid-template-columns CSS value
 */
function columnsToCSS(columns: ComponentColumns): string {
  if (typeof columns === 'number') {
    return `repeat(${columns}, 1fr)`
  }
  return `repeat(${columns}, minmax(200px, 1fr))`
}

// In your component:
const columnsStyles = responsiveStyles(
  'gridTemplateColumns',
  columns,
  columnsToCSS,
)
const emotionStyles = css`
  ${columnsStyles}
`
```

**Guidelines for custom conversion functions:**

- Create a function that converts a single value to its CSS string representation
- Pass this function as the third argument to `responsiveStyles`
- The function should handle all possible input types for that prop
- Keep conversion logic simple and focused on transforming values to CSS strings

#### 4. Emotion Handles Media Queries Automatically

Emotion automatically generates all media queries at runtime. You don't need to write any CSS media queries manually. The `responsiveStyles` utility handles:

- Base styles (no media query) for simple values or `base` breakpoint
- Media queries for each breakpoint (xs, sm, md, lg) when using responsive objects
- Proper CSS with correct breakpoint values from `tokens/breakpoints.ts`

**How it works:**

When you use `responsiveStyles`, Emotion generates CSS like this at runtime:

```tsx
// Input:
const gapStyles = responsiveStyles('gap', { base: 'sm', md: 'lg' }, gapToCSS)

// Emotion generates (conceptually):
// gap: var(--space-2);  // base value
// @media (min-width: 1024px) {
//   gap: var(--space-6);  // md value
// }
```

You don't need to write any CSS for responsive behavior - Emotion handles it all automatically.

### Key Implementation Details

**1. Emotion Handles Everything**

With Emotion, you don't need to manually manage CSS custom properties or data attributes. Emotion generates and injects the CSS at runtime, including all media queries.

**2. CSS Custom Property Naming (Internal)**

CSS custom properties follow this pattern:

```
--{componentName}-{propName}-{breakpoint}
```

Examples:

- `--box-padding-base`
- `--flex-gap-sm`
- `--grid-columns-lg`

**3. Fallback Chains**

Use nested `var()` functions to create fallback chains that inherit from smaller breakpoints:

```css
/* At sm breakpoint, try sm first, then xs, then base */
padding: var(
  --component-padding-sm,
  var(--component-padding-xs, var(--component-padding-base))
);
```

**4. CSS Property Names**

When using `responsiveStyles`, pass the CSS property name directly (e.g., `'gap'`, `'padding'`, `'gridTemplateAreas'`). Emotion handles the rest automatically.

### Backward Compatibility

Responsive props maintain backward compatibility with simple values. If a user passes a simple value, it works exactly as before:

```tsx
// Both work identically for non-responsive usage
<Box padding="md" />
<Box padding={{ base: 'md' }} />
```

#### Maintaining Class Names with Responsive Props

When your component has existing CSS that relies on class names (e.g., variant styles, size modifiers), you should maintain class names for the base value even when using responsive props. This allows existing CSS rules to continue working:

```tsx
/**
 * Get class name for a prop
 * For responsive objects, returns the base value's class name
 * For simple values, returns the value's class name
 * This allows existing CSS (like variant styles) to work with responsive props
 */
function getGapClassName(
  value: Responsive<ComponentGap> | undefined,
): string | false {
  if (!value) return false

  if (isResponsiveObject(value)) {
    // For responsive objects, use the base value for the class name
    // This allows variant styles to work with responsive props at the base breakpoint
    return value.base !== undefined ? `zen-component--gap-${value.base}` : false
  }

  return `zen-component--gap-${value}`
}

// In your component:
const classNames = [
  'zen-component',
  getGapClassName(gap), // Always adds base class, even for responsive props
  className,
]
  .filter(Boolean)
  .join(' ')
```

**Why this matters:**

- Existing CSS rules that target class names (e.g., `.zen-shoji-grid--gap-md`) continue to work
- The base breakpoint uses the class name, while responsive breakpoints use CSS custom properties
- You can add data attributes for breakpoint-specific values to enable more complex CSS rules

**When to use breakpoint-specific data attributes:**

Breakpoint-specific data attributes (e.g., `data-gap-base`, `data-gap-md`) are useful when:

- You need CSS rules that vary based on the specific breakpoint value (not just whether it's responsive)
- You want to write CSS that targets specific prop values at specific breakpoints
- Your component has variant styles that need to respond to breakpoint-specific prop values
- You need to create complex CSS selectors that combine breakpoint data attributes with other selectors

**Example: Using breakpoint-specific data attributes**

```tsx
// Add data attributes for breakpoint-specific values
if (gap && isResponsiveObject(gap)) {
  dataAttributes['data-has-responsive-gap'] = 'true'
  if (gap.base !== undefined) {
    dataAttributes['data-gap-base'] = gap.base
  }
  if (gap.xs !== undefined) {
    dataAttributes['data-gap-xs'] = gap.xs
  }
  if (gap.sm !== undefined) {
    dataAttributes['data-gap-sm'] = gap.sm
  }
  if (gap.md !== undefined) {
    dataAttributes['data-gap-md'] = gap.md
  }
  if (gap.lg !== undefined) {
    dataAttributes['data-gap-lg'] = gap.lg
  }
}
```

This enables CSS rules like:

```css
/* Apply different frame widths based on gap value at md breakpoint */
.zen-component[data-has-responsive-gap='true'][data-gap-md='md'] {
  --frame-width: var(--frame-width-md);
}
```

This pattern allows you to write CSS that works with both class names and responsive props. **Prefer defining dedicated CSS custom properties instead of using `calc()` expressions:**

```css
/* Define all size variants as custom properties in the base variant */
.component--variant {
  --frame-width: 3px;
  --frame-width-md: 4px;
  --frame-width-lg: 5px;
  --frame-width-xl: 6px;
}

/* Works with class name (base breakpoint) */
.component--variant.component--gap-md {
  gap: var(--frame-width-md);
}

/* Works with responsive props (all breakpoints) */
.component--variant[data-has-responsive-gap='true'][data-gap-md='md'] {
  gap: var(--frame-width-md);
}
```

This approach makes values easier to customize, reduces computation, and improves maintainability compared to using `calc()` expressions.

**5. TypeScript Constants for CSS Custom Properties**

For complex components with many responsive props, consider creating a constants file with typed CSS custom property names. This prevents typos and provides type safety:

```tsx
// {ComponentName}Constants.ts
export const {COMPONENT_NAME}_PADDING_BASE = '--{componentName}-padding-base'
export const {COMPONENT_NAME}_PADDING_XS = '--{componentName}-padding-xs'
export const {COMPONENT_NAME}_PADDING_SM = '--{componentName}-padding-sm'
export const {COMPONENT_NAME}_PADDING_MD = '--{componentName}-padding-md'
export const {COMPONENT_NAME}_PADDING_LG = '--{componentName}-padding-lg'

export const {COMPONENT_NAME}_GAP_BASE = '--{componentName}-gap-base'
export const {COMPONENT_NAME}_GAP_XS = '--{componentName}-gap-xs'
// ... etc
```

Then use these constants when referencing CSS custom properties in your code:

```tsx
// In component or test files
const baseValue = getComputedStyle(element).getPropertyValue(
  {COMPONENT_NAME}_PADDING_BASE,
)
```

**Note for Compound Components:** When sub-components extend other component props (like `BoxProps`), they can reuse the parent component's Emotion style utilities. For example, a `GridCell` component that extends `BoxProps` can use `getPaddingEmotionStyles` from Box, allowing it to reuse Box padding styles.

### Best Practices

<Guideline type="do">
  Make all visual props responsive (padding, margin, gap, columns, sizes, etc.)
</Guideline>

<Guideline type="do">
  Use Emotion's `responsiveStyles` utility for all responsive props
</Guideline>

<Guideline type="do">
  Define dedicated CSS custom properties for size variants instead of using
  `calc()` expressions (e.g., `--component-size-md: 4px` instead of
  `calc(var(--component-size) + 1px)`)
</Guideline>

<Guideline type="do">
  Keep CSS files for base styles, variants, and states only
</Guideline>

<Guideline type="dont">
  Make event handlers, refs, or children responsive
</Guideline>

<Guideline type="dont">
  Create responsive props for non-visual props (event handlers, refs, children,
  etc.)
</Guideline>

---

## Testing

Comprehensive testing ensures your component works correctly across all scenarios. Use Vitest and React Testing Library for component testing.

### Testing Framework Setup

**Required dependencies:**

```json
{
  "devDependencies": {
    "vitest": "^1.0.0",
    "@testing-library/react": "^14.0.0",
    "@testing-library/jest-dom": "^6.0.0"
  }
}
```

**Test file structure:**

Create a `ComponentName.test.tsx` file in your component directory:

```tsx
import { describe, it, expect } from 'vitest'
import { render } from '@testing-library/react'
import { ComponentName } from './ComponentName'

describe('ComponentName', () => {
  // Test cases here
})
```

### What to Test

#### 1. Component Rendering

Test that your component renders correctly with basic props:

```tsx
it('should render with children', () => {
  const { getByText } = render(<ComponentName>Test Content</ComponentName>)
  expect(getByText('Test Content')).toBeInTheDocument()
})

it('should render with default props', () => {
  const { container } = render(<ComponentName />)
  const element = container.querySelector('.zen-component')
  expect(element).toBeInTheDocument()
})
```

#### 2. CSS Custom Properties

Test that responsive props generate the correct CSS custom properties:

```tsx
it('should set correct CSS custom properties for responsive props', () => {
  const { container } = render(
    <ComponentName padding={{ base: 'sm', md: 'lg' }} />,
  )
  const element = container.querySelector('.zen-component') as HTMLElement

  // Check base value
  const baseValue = getComputedStyle(element).getPropertyValue(
    '--component-padding-base',
  )
  expect(baseValue.trim()).toBe('var(--space-2)')

  // Check md value
  const mdValue = getComputedStyle(element).getPropertyValue(
    '--component-padding-md',
  )
  expect(mdValue.trim()).toBe('var(--space-6)')
})
```

**Using constants (recommended):**

```tsx
import {
  {COMPONENT_NAME}_PADDING_BASE,
  {COMPONENT_NAME}_PADDING_MD,
} from './{ComponentName}Constants'

it('should set correct CSS custom properties', () => {
  const { container } = render(
    <ComponentName padding={{ base: 'sm', md: 'lg' }} />,
  )
  const element = container.querySelector('.zen-component') as HTMLElement

  const baseValue = getComputedStyle(element).getPropertyValue(
    {COMPONENT_NAME}_PADDING_BASE,
  )
  expect(baseValue.trim()).toBe('var(--space-2)')
})
```

#### 3. Data Attributes

Test that data attributes are set correctly for responsive props:

```tsx
it('should set data-has-responsive-padding attribute when using responsive padding', () => {
  const { container } = render(
    <ComponentName padding={{ base: 'sm', md: 'lg' }} />,
  )
  const element = container.querySelector('.zen-component')

  expect(element).toHaveAttribute('data-has-responsive-padding', 'true')
})

it('should not set data attribute for simple (non-responsive) values', () => {
  const { container } = render(<ComponentName padding="sm" />)
  const element = container.querySelector('.zen-component')

  expect(element).not.toHaveAttribute('data-has-responsive-padding')
})
```

#### 4. Responsive Behavior

Test that responsive props work correctly at different breakpoints:

```tsx
it('should apply correct values at base breakpoint', () => {
  const { container } = render(<ComponentName gap={{ base: 'sm', md: 'md' }} />)
  const element = container.querySelector('.zen-component') as HTMLElement

  const baseValue = getComputedStyle(element).getPropertyValue(
    '--component-gap-base',
  )
  expect(baseValue.trim()).toBe('var(--grid-gap-sm)')
})

it('should set breakpoint-specific values', () => {
  const { container } = render(<ComponentName gap={{ base: 'sm', md: 'md' }} />)
  const element = container.querySelector('.zen-component') as HTMLElement

  const mdValue =
    getComputedStyle(element).getPropertyValue('--component-gap-md')
  expect(mdValue.trim()).toBe('var(--grid-gap-md)')
})
```

#### 5. CSS Variable Resolution

Test that CSS variables resolve correctly (when tokens are loaded):

```tsx
it('should have root-level tokens defined with correct values', () => {
  const rootStyles = getComputedStyle(document.documentElement)

  const spaceSm = rootStyles.getPropertyValue('--space-2')
  const spaceLg = rootStyles.getPropertyValue('--space-6')

  expect(spaceSm.trim()).toBe('0.5rem') // Adjust to your actual token values
  expect(spaceLg.trim()).toBe('1.5rem')
})

it('should set component-level variables that reference root tokens', () => {
  const { container } = render(
    <ComponentName padding={{ base: 'sm', md: 'lg' }} />,
  )
  const element = container.querySelector('.zen-component') as HTMLElement
  const elementStyles = getComputedStyle(element)

  const baseValue = elementStyles.getPropertyValue('--component-padding-base')
  expect(baseValue.trim()).toBe('var(--space-2)')

  // Verify root token exists
  const rootStyles = getComputedStyle(document.documentElement)
  const rootSpaceSm = rootStyles.getPropertyValue('--space-2')
  expect(rootSpaceSm.trim()).toBe('0.5rem')
})
```

#### 6. Component Props and Variants

Test that all props and variants work correctly:

```tsx
it('should apply variant class correctly', () => {
  const { container } = render(<ComponentName variant="primary" />)
  const element = container.querySelector('.zen-component')

  expect(element).toHaveClass('zen-component--primary')
})

it('should apply size class correctly', () => {
  const { container } = render(<ComponentName size="lg" />)
  const element = container.querySelector('.zen-component')

  expect(element).toHaveClass('zen-component--lg')
})

it('should handle disabled state', () => {
  const { container } = render(<ComponentName disabled />)
  const element = container.querySelector('.zen-component')

  expect(element).toHaveAttribute('aria-disabled', 'true')
})
```

#### 7. Conversion Functions

Test that conversion functions convert values correctly:

```tsx
import { gapToCSS } from './ComponentName'

describe('gapToCSS', () => {
  it('should convert simple value to CSS', () => {
    const result = gapToCSS('sm')
    expect(result).toBe('var(--grid-gap-sm)')
  })

  it('should convert all gap values correctly', () => {
    expect(gapToCSS('none')).toBe('0')
    expect(gapToCSS('sm')).toBe('var(--grid-gap-sm)')
    expect(gapToCSS('md')).toBe('var(--grid-gap-md)')
  })
})
```

#### 8. Compound Components

Test compound components (components with sub-components):

```tsx
it('should render compound component correctly', () => {
  const { container } = render(
    <ComponentName>
      <ComponentName.Item>Item 1</ComponentName.Item>
      <ComponentName.Item>Item 2</ComponentName.Item>
    </ComponentName>,
  )

  const items = container.querySelectorAll('.zen-component-item')
  expect(items).toHaveLength(2)
})

it('should apply props to sub-components', () => {
  const { container } = render(
    <ComponentName>
      <ComponentName.Item area="header">Header</ComponentName.Item>
    </ComponentName>,
  )

  const item = container.querySelector('.zen-component-item') as HTMLElement
  const style = getComputedStyle(item)
  expect(style.gridArea).toBe('header')
})
```

### How to Test

#### Testing CSS Custom Properties

Use `getComputedStyle` to read CSS custom properties:

```tsx
const element = container.querySelector('.zen-component') as HTMLElement
const styles = getComputedStyle(element)

// Read a CSS custom property
const paddingBase = styles.getPropertyValue('--component-padding-base')
expect(paddingBase.trim()).toBe('var(--space-2)')
```

**Note:** In jsdom (Vitest's default environment), CSS variables don't fully resolve. You can verify that:

- CSS custom properties are set correctly
- Data attributes are present
- The structure is correct

For full CSS variable resolution testing, use a browser-based test environment or Storybook.

#### Testing Data Attributes

Use React Testing Library's `toHaveAttribute` matcher:

```tsx
expect(element).toHaveAttribute('data-has-responsive-padding', 'true')
expect(element).toHaveAttribute('data-gap-base', 'sm')
```

#### Testing Responsive Behavior

Test responsive behavior by verifying:

1. CSS custom properties are set for each breakpoint
2. Data attributes indicate responsive usage
3. Fallback chains are structured correctly

```tsx
it('should have correct fallback chain structure', () => {
  const { container } = render(<ComponentName gap={{ base: 'sm', md: 'md' }} />)
  const element = container.querySelector('.zen-component') as HTMLElement

  // Verify base is set
  const base = getComputedStyle(element).getPropertyValue(
    '--component-gap-base',
  )
  expect(base.trim()).toBe('var(--grid-gap-sm)')

  // Verify md is set (will fallback to base if not set)
  const md = getComputedStyle(element).getPropertyValue('--component-gap-md')
  expect(md.trim()).toBe('var(--grid-gap-md)')

  // Verify xs is not set (should be empty)
  const xs = getComputedStyle(element).getPropertyValue('--component-gap-xs')
  expect(xs.trim()).toBe('')
})
```

#### Testing Utilities and Helpers

Create helper functions for common test patterns:

```tsx
// test-utils.tsx
export function getComponentStyles(container: HTMLElement, selector: string) {
  const element = container.querySelector(selector) as HTMLElement
  return getComputedStyle(element)
}

export function getCSSVariable(
  container: HTMLElement,
  selector: string,
  variable: string,
): string {
  const styles = getComponentStyles(container, selector)
  return styles.getPropertyValue(variable).trim()
}

// Usage in tests:
it('should set padding correctly', () => {
  const { container } = render(<ComponentName padding="sm" />)
  const padding = getCSSVariable(
    container,
    '.zen-component',
    '--component-padding-base',
  )
  expect(padding).toBe('var(--space-2)')
})
```

### Testing Best Practices

<Guideline type="do">
  Test CSS custom properties are set correctly for responsive props
</Guideline>

<Guideline type="do">
  Test data attributes are applied when responsive props are used
</Guideline>

<Guideline type="do">
  Test normalization functions separately from component rendering
</Guideline>

<Guideline type="do">Test both simple and responsive prop values</Guideline>

<Guideline type="do">
  Use constants for CSS custom property names in tests
</Guideline>

<Guideline type="dont">
  Test CSS variable resolution in jsdom (they don't fully resolve)
</Guideline>

<Guideline type="dont">
  Test media query behavior in unit tests (use Storybook or browser tests)
</Guideline>

<Guideline type="dont">
  Test implementation details - focus on behavior and output
</Guideline>

---

## Storybook Stories

### File Structure

```tsx
import type { Meta, StoryObj } from '@storybook/react'
import { ComponentName } from './ComponentName'

const meta: Meta<typeof ComponentName> = {
  title: 'Components/ComponentName',
  component: ComponentName,
  tags: ['autodocs'],
  parameters: {
    layout: 'fullscreen',
  },
  argTypes: {
    // Define controls for each prop
  },
}

export default meta
type Story = StoryObj<typeof ComponentName>
```

### Configuring ArgTypes

Provide meaningful controls and descriptions for each prop:

```tsx
argTypes: {
  variant: {
    control: 'select',
    options: ['primary', 'secondary', 'outline', 'ghost'],
    description: 'The visual style variant',
  },
  size: {
    control: 'select',
    options: ['sm', 'md', 'lg'],
    description: 'The size of the component',
  },
  disabled: {
    control: 'boolean',
    description: 'Whether the component is disabled',
  },
}
```

---

## Story Granularity

Stories should be **comprehensive but focused**. Each story should demonstrate
a specific aspect of the component.

### Playground Story (Required)

Every component **must** include a `Playground` story as the first story. This provides an interactive sandbox where developers can experiment with all props using Storybook controls.

```tsx
export const Playground: Story = {
  args: {
    children: 'Button',
    variant: 'primary',
    size: 'md',
    disabled: false,
  },
}
```

The Playground story should:

- Be the first exported story (appears at the top of the component's story list)
- Include sensible default values for all props via `args`
- Enable full interactivity through Storybook's Controls panel

### Using Design Tokens in Stories

Always use design tokens instead of hardcoded pixel or rem values in story layouts. This ensures visual consistency with the design system.

<Guideline type="do">

```tsx
<div style={{ display: 'flex', gap: 'var(--space-4)', alignItems: 'center' }}>
  <Button variant="primary">Primary</Button>
  <Button variant="secondary">Secondary</Button>
</div>
```

</Guideline>

<Guideline type="dont">

```tsx
<div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
  <Button variant="primary">Primary</Button>
  <Button variant="secondary">Secondary</Button>
</div>
```

</Guideline>

### Required Stories

Every component should include these essential stories:

<div
  style={{
    padding: '1.5rem',
    backgroundColor: 'var(--color-surface)',
    border: '1px solid var(--color-border-subtle)',
    borderRadius: 'var(--radius-md)',
    marginBottom: '1.5rem',
  }}
>
  <h4
    style={{
      margin: '0 0 1rem 0',
      fontSize: 'var(--font-size-base)',
      fontWeight: 'var(--font-weight-semibold)',
      color: 'var(--color-text-primary)',
    }}
  >
    Essential Stories Checklist
  </h4>
  <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>Playground</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Interactive sandbox with all props via args
      </span>
    </div>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>All Variants</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Shows each variant side by side
      </span>
    </div>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>All Sizes</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Shows each size side by side
      </span>
    </div>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>Disabled State</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Shows disabled state for each variant
      </span>
    </div>
  </div>
</div>

### Story Patterns

#### Composite Stories (Preferred for Visual Comparison)

Show multiple variations in a single story for easy visual comparison:

```tsx
export const AllVariants: Story = {
  name: 'All Variants',
  render: () => (
    <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
      <ComponentName variant="primary">Primary</ComponentName>
      <ComponentName variant="secondary">Secondary</ComponentName>
      <ComponentName variant="outline">Outline</ComponentName>
    </div>
  ),
}
```

#### State Stories

Group related states together:

```tsx
export const Disabled: Story = {
  render: () => (
    <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
      <ComponentName variant="primary" disabled>
        Primary
      </ComponentName>
      <ComponentName variant="secondary" disabled>
        Secondary
      </ComponentName>
      <ComponentName variant="outline" disabled>
        Outline
      </ComponentName>
    </div>
  ),
}
```

### When to Create Separate Stories

Create individual stories for:

- **Complex interactions** that need isolated testing
- **Edge cases** like very long content or unusual states
- **Responsive behavior** that needs viewport controls
- **Integration examples** showing component combinations

### Story Naming

Use clear, descriptive names with the `name` property:

```tsx
export const AllVariants: Story = {
  name: 'All Variants',
  // ...
}

export const WithLongContent: Story = {
  name: 'With Long Content',
  // ...
}
```

---

## Barrel Exports

The `index.ts` file should export the component and all its types:

```tsx
export { ComponentName } from './ComponentName'
export type {
  ComponentNameProps,
  ComponentVariant,
  ComponentSize,
} from './ComponentName'
```

---

## Compound Components

When a component has sub-components (e.g., `ComponentName.Item`), follow this pattern:

### File Structure

Extract sub-components to separate files when they:

- Have their own props interface
- Support responsive props independently
- Are complex enough to warrant separation

Example: `ComponentName` and `ComponentNameItem`

```
src/components/ComponentName/
├── ComponentName.tsx          # Main ComponentName component
├── ComponentNameItem.tsx     # ComponentName.Item sub-component
├── ComponentName.css
├── ComponentName.stories.tsx
└── index.ts
```

### Implementation Pattern

```tsx
// ComponentNameItem.tsx
export interface ComponentNameItemProps extends BoxProps {
  area?: string
  column?: string
  row?: string
}

export const ComponentNameItem = forwardRef<
  HTMLDivElement,
  ComponentNameItemProps
>(({ area, column, row, ...props }, ref) => {
  // Implementation with responsive props support
})

ComponentNameItem.displayName = 'ComponentName.Item'

// ComponentName.tsx
import { ComponentNameItem } from './ComponentNameItem'

const ComponentNameRoot = forwardRef<HTMLDivElement, ComponentNameProps>(
  ({ ...props }, ref) => {
    // Implementation
  },
)

ComponentNameRoot.displayName = 'ComponentName'

// Compound component pattern
export const ComponentName = Object.assign(ComponentNameRoot, {
  Item: ComponentNameItem,
})
```

### Export Pattern

```tsx
// index.ts
export { ComponentName } from './ComponentName'
export type { ComponentNameProps, ... } from './ComponentName'
export type { ComponentNameItemProps } from './ComponentNameItem'
```

### Responsive Props in Sub-Components

Sub-components that extend other component props (like `FlexProps`) should:

- Use the parent component's CSS prefix (e.g., 'flex' for components extending FlexProps)
- Support all responsive props from the parent interface
- Add data attributes for responsive props
- Only add class names for non-responsive values

```tsx
// GridCell can reuse Box's padding styles utility
import { getPaddingEmotionStyles } from '../Box/boxPaddingStyles'

const paddingStyles = getPaddingEmotionStyles(
  padding,
  paddingHorizontal,
  paddingVertical,
)
const emotionStyles = css`
  ${paddingStyles}
`
```

This allows sub-components to reuse the parent component's Emotion style utilities while maintaining their own implementation.

---

## Checklist

Before submitting a new component, verify:

<div
  style={{
    padding: '1.5rem',
    backgroundColor: 'var(--color-surface)',
    border: '1px solid var(--color-border-subtle)',
    borderRadius: 'var(--radius-md)',
  }}
>
  <div
    style={{
      display: 'grid',
      gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
      gap: '1rem',
    }}
  >
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Implementation
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Uses <code>forwardRef</code> for DOM access
        </li>
        <li>Extends appropriate native HTML attributes</li>
        <li>Has JSDoc comments on all props</li>
        <li>
          Sets <code>displayName</code> for debugging
        </li>
        <li>Provides sensible default prop values</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Styling
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>Uses only design tokens (no hardcoded values)</li>
        <li>
          Has <code>zen-</code> prefix on all classes
        </li>
        <li>Defines all interactive states</li>
        <li>Includes focus-visible styles</li>
        <li>Has disabled state with proper cursor</li>
        <li>Uses SCSS mixins for responsive props (if using SCSS)</li>
        <li>Data attributes conditionally apply CSS rules</li>
        <li>CSS custom properties use proper naming conventions</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Responsive Props
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Uses <code>Responsive&lt;T&gt;</code> type for responsive props
        </li>
        <li>Normalizes semantic values to CSS (if needed)</li>
        <li>
          Uses <code>responsiveStyles</code> to generate Emotion CSS with media
          queries
        </li>
        <li>
          Combines Emotion styles with CSS classes for backward compatibility
        </li>
        <li>Handles camelCase prop names correctly</li>
        <li>Maintains class names for backward compatibility</li>
        <li>CSS includes fallback chains for all breakpoints</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Constants
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>Constants file created (if component has 3+ responsive props)</li>
        <li>
          Constants use <code>UPPER_SNAKE_CASE</code> naming
        </li>
        <li>Constants match CSS custom property naming pattern</li>
        <li>Constants exported for use in tests and component</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Testing
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>Test file created with component tests</li>
        <li>Tests component rendering</li>
        <li>Tests CSS custom properties are set correctly</li>
        <li>Tests data attributes are applied</li>
        <li>Tests responsive prop behavior</li>
        <li>Tests normalization functions (if applicable)</li>
        <li>Tests component variants and props</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Storybook
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Has <code>Playground</code> story as first story
        </li>
        <li>
          Has <code>autodocs</code> tag enabled
        </li>
        <li>Includes stories for all variants</li>
        <li>Includes stories for all sizes</li>
        <li>Shows disabled states</li>
        <li>Uses design tokens in story layouts</li>
        <li>
          Has descriptive <code>argTypes</code>
        </li>
        <li>Passes a11y addon checks</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Exports
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Has barrel export in <code>index.ts</code>
        </li>
        <li>Exports component and all types</li>
        <li>Added to main library exports</li>
      </ul>
    </div>
  </div>
</div>

**Note:** Not all checklist items apply to every component. Use your judgment based on component complexity. For example:

- Simple components may not need constants files
- All components should have tests, but complexity varies
