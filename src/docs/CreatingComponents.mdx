{/* CreatingComponents.mdx */}
import { Meta } from '@storybook/blocks';

<Meta title="Guidelines/Creating Components" />

# Creating Components

A comprehensive guide to building components for the Zen Design System. Follow these
patterns to ensure consistency, maintainability, and a great developer experience.

export const FileCard = ({ name, description }) => (
  <div
    style={{
      display: 'flex',
      alignItems: 'flex-start',
      gap: '1rem',
      padding: '1rem',
      backgroundColor: 'var(--color-surface)',
      border: '1px solid var(--color-border-subtle)',
      borderRadius: 'var(--radius-md)',
      marginBottom: '0.5rem',
    }}
  >
    <code
      style={{
        padding: '0.25rem 0.5rem',
        backgroundColor: 'var(--color-primary-subtle)',
        color: 'var(--color-primary)',
        borderRadius: 'var(--radius-sm)',
        fontFamily: 'var(--font-family-mono)',
        fontSize: 'var(--font-size-sm)',
        whiteSpace: 'nowrap',
      }}
    >
      {name}
    </code>
    <span
      style={{
        fontSize: 'var(--font-size-sm)',
        color: 'var(--color-text-secondary)',
        lineHeight: 'var(--line-height-body)',
      }}
    >
      {description}
    </span>
  </div>
)

export const Guideline = ({ type, children }) => {
  const colors = {
    do: {
      bg: 'var(--color-secondary-50)',
      border: 'var(--color-secondary-500)',
      label: '✓ Do',
    },
    dont: { bg: '#fef2f2', border: '#ef4444', label: "✗ Don't" },
  }
  const style = colors[type]
  return (
    <div
      style={{
        padding: '1rem',
        backgroundColor: style.bg,
        borderLeft: `4px solid ${style.border}`,
        borderRadius: 'var(--radius-md)',
        marginBottom: '0.75rem',
      }}
    >
      <div
        style={{
          fontWeight: 'var(--font-weight-semibold)',
          fontSize: 'var(--font-size-sm)',
          color: style.border,
          marginBottom: '0.5rem',
        }}
      >
        {style.label}
      </div>
      <div
        style={{
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-primary)',
        }}
      >
        {children}
      </div>
    </div>
  )
}

---

## File Structure

Each component should live in its own folder within `src/components/` with the
following structure:

<FileCard
  name="ComponentName.tsx"
  description="The main component implementation with TypeScript types and props interface."
/>
<FileCard
  name="ComponentName.css (or .scss)"
  description="Component-specific styles using CSS custom properties from design tokens."
/>
<FileCard
  name="ComponentName.stories.tsx"
  description="Storybook stories showcasing all variants, sizes, and states."
/>
<FileCard
  name="ComponentName.test.tsx"
  description="Component tests using Vitest and React Testing Library (optional but recommended)."
/>
<FileCard
  name="{ComponentName}Constants.ts"
  description="Typed constants for CSS custom property names (optional, for complex components)."
/>
<FileCard name="index.ts" description="Barrel export file for clean imports." />

### Example Structure

**Basic component:**

```
src/components/
└── ComponentName/
    ├── ComponentName.tsx
    ├── ComponentName.css
    ├── ComponentName.stories.tsx
    ├── ComponentName.test.tsx
    └── index.ts
```

**Component with constants:**

```
src/components/
└── ComponentName/
    ├── ComponentName.tsx
    ├── ComponentName.css
    ├── ComponentName.stories.tsx
    ├── ComponentName.test.tsx
    ├── {ComponentName}Constants.ts
    └── index.ts
```

**Note:** For compound components with sub-components, extract sub-components to separate files when they become complex:

```
src/components/
└── ComponentName/
    ├── ComponentName.tsx      # Main component
    ├── ComponentNameSub.tsx    # Sub-component (e.g., GridCell)
    ├── ComponentName.css
    ├── ComponentName.stories.tsx
    ├── ComponentName.test.tsx
    ├── {ComponentName}Constants.ts  # Optional
    └── index.ts               # Exports both components
```

---

## YAGNI Principle

**You Ain't Gonna Need It** — build only what is explicitly required.

The Zen Design System follows a minimal implementation philosophy. Before adding any feature or prop, ask yourself: "Is this explicitly requested or documented in the requirements?"

<div
  style={{
    padding: '1.5rem',
    backgroundColor: 'var(--color-surface)',
    border: '1px solid var(--color-border-subtle)',
    borderRadius: 'var(--radius-md)',
    marginBottom: '1.5rem',
  }}
>
  <h4
    style={{
      margin: '0 0 1rem 0',
      fontSize: 'var(--font-size-base)',
      fontWeight: 'var(--font-weight-semibold)',
      color: 'var(--color-text-primary)',
    }}
  >
    YAGNI Guidelines
  </h4>
  <ul
    style={{
      margin: 0,
      paddingLeft: '1.25rem',
      fontSize: 'var(--font-size-sm)',
      color: 'var(--color-text-secondary)',
      lineHeight: '1.8',
    }}
  >
    <li>Only add props or functionality that is explicitly requested</li>
    <li>Avoid speculative features ("this might be useful someday")</li>
    <li>Start with the minimal viable implementation</li>
    <li>Add complexity only when real use cases demand it</li>
    <li>Prefer composition over configuration</li>
  </ul>
</div>

<Guideline type="do">
  Build the exact feature requested. If a Button is needed with primary and
  secondary variants, implement only those two variants.
</Guideline>

<Guideline type="dont">
  Add extra variants, sizes, or props "just in case" — you can always add them
  later when a real need arises.
</Guideline>

---

## Accessibility

Building accessible components is essential for the Zen Design System. Every component must be usable by everyone, including people who rely on assistive technologies.

### Focus Management

- All interactive elements must be focusable
- Use `:focus-visible` for keyboard focus states (not `:focus`)
- Ensure focus order follows a logical reading sequence
- Trap focus within modals and dialogs when open

```css
.zen-component:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--color-focus-ring);
}
```

### Keyboard Navigation

- Support expected keyboard interactions for each component type
- Buttons: `Enter` and `Space` to activate
- Menus: Arrow keys to navigate, `Escape` to close
- Tabs: Arrow keys to switch, `Tab` to move focus
- Document all keyboard shortcuts in stories

### ARIA Attributes

Use ARIA attributes to enhance semantic meaning:

```tsx
// Button with loading state
<button aria-busy={loading} aria-disabled={disabled}>
  {loading ? 'Loading...' : children}
</button>

// Expandable section
<button aria-expanded={isOpen} aria-controls="panel-id">
  Toggle Panel
</button>
```

### Color Contrast

- Text must meet WCAG 2.1 AA contrast ratios (4.5:1 for normal text, 3:1 for large text)
- Use design tokens that have been verified for accessibility
- Never rely on color alone to convey information

### Testing with a11y Addon

The Storybook a11y addon is configured to automatically audit components. Check the "Accessibility" tab in Storybook to verify your component passes all checks:

- No violations should appear in the accessibility panel
- Test with keyboard-only navigation
- Verify screen reader announcements are meaningful

---

## Component Implementation

### TypeScript & Props

Define explicit types for all prop options using union types, and create a dedicated
props interface that extends native HTML attributes.

```tsx
import { HTMLAttributes, forwardRef } from 'react'
import './ComponentName.css'

export type ComponentVariant = 'primary' | 'secondary' | 'outline'
export type ComponentSize = 'sm' | 'md' | 'lg'

export interface ComponentNameProps extends HTMLAttributes<HTMLDivElement> {
  /** The visual style variant */
  variant?: ComponentVariant
  /** The size of the component */
  size?: ComponentSize
}
```

### Using forwardRef

Always use `forwardRef` to allow consumers to access the underlying DOM element:

```tsx
export const ComponentName = forwardRef<HTMLDivElement, ComponentNameProps>(
  (
    { variant = 'primary', size = 'md', className = '', children, ...props },
    ref,
  ) => {
    // Implementation
  },
)

ComponentName.displayName = 'ComponentName'
```

### CSS Class Construction

Build class names systematically using a consistent pattern:

```tsx
const classNames = [
  'zen-component',
  `zen-component--${variant}`,
  `zen-component--${size}`,
  className,
]
  .filter(Boolean)
  .join(' ')
```

---

## Naming Conventions

### Props

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
    gap: '1rem',
    marginBottom: '1.5rem',
  }}
>
  <div>
    <Guideline type="do">
      Use `variant` for visual style options (primary, secondary, outline,
      ghost)
    </Guideline>
    <Guideline type="do">
      Use `size` for dimension options (sm, md, lg)
    </Guideline>
    <Guideline type="do">
      Use boolean props for binary states: `disabled`, `loading`, `selected`
    </Guideline>
    <Guideline type="do">
      Use JSDoc comments with `/** */` to document each prop
    </Guideline>
  </div>
  <div>
    <Guideline type="dont">
      Use `type` or `style` for variants (conflicts with native attributes)
    </Guideline>
    <Guideline type="dont">Abbreviate prop names: `var`, `sz`, `dis`</Guideline>
    <Guideline type="dont">
      Use negative booleans: `notDisabled`, `isNotLoading`
    </Guideline>
    <Guideline type="dont">Create props for single-use edge cases</Guideline>
  </div>
</div>

### Common Prop Patterns

<table
  style={{
    width: '100%',
    borderCollapse: 'collapse',
    fontSize: 'var(--font-size-sm)',
  }}
>
  <thead>
    <tr style={{ borderBottom: '2px solid var(--color-border)' }}>
      <th
        style={{
          textAlign: 'left',
          padding: '0.75rem',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Prop
      </th>
      <th
        style={{
          textAlign: 'left',
          padding: '0.75rem',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Type
      </th>
      <th
        style={{
          textAlign: 'left',
          padding: '0.75rem',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Purpose
      </th>
    </tr>
  </thead>
  <tbody>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>variant</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Union type
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Visual style (primary, secondary, outline, ghost)
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>size</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>'sm' | 'md' | 'lg'</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Component dimensions
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>disabled</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Disables interaction
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>loading</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Shows loading state
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>selected</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Indicates selection
      </td>
    </tr>
    <tr>
      <td style={{ padding: '0.75rem' }}>
        <code>fullWidth</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Expands to container width
      </td>
    </tr>
  </tbody>
</table>

### CSS Classes

- **Prefix all classes** with `zen-` to prevent collisions
- Use **BEM-style modifiers** with double dashes: `zen-component--variant`
- Keep class names **lowercase with hyphens**: `zen-card-header`

```css
.zen-component {
  /* Base styles */
}
.zen-component--primary {
  /* Variant styles */
}
.zen-component--sm {
  /* Size styles */
}
```

---

## Styling Guidelines

### Use Design Tokens

Always use CSS custom properties from the design system. Never use hardcoded values.

<Guideline type="do">

```css
.zen-component {
  padding: var(--space-3) var(--space-4);
  font-size: var(--font-size-base);
  border-radius: var(--radius-md);
  color: var(--color-text-primary);
}
```

</Guideline>

<Guideline type="dont">

```css
.zen-component {
  padding: 12px 16px;
  font-size: 16px;
  border-radius: 8px;
  color: #333333;
}
```

</Guideline>

### CSS File Organization

Structure your CSS file with clear sections:

```css
/* ============================================
   COMPONENT NAME
   ============================================ */

.zen-component {
  /* Reset */
  /* Layout */
  /* Typography */
  /* Shape */
  /* Interaction */
}

/* ----------------------------------------
   SIZE VARIANTS
   ---------------------------------------- */

.zen-component--sm {
}
.zen-component--md {
}
.zen-component--lg {
}

/* ----------------------------------------
   STYLE VARIANTS
   ---------------------------------------- */

.zen-component--primary {
}
.zen-component--secondary {
}
```

### Component-Level CSS Variables

Define component-specific CSS custom properties to enable easy customization and maintain consistency across size variants:

```css
.zen-button--md {
  --button-height: 2.5rem;
  --button-padding-x: var(--space-4);
  --button-font-size: var(--font-size-base);

  height: var(--button-height);
  padding: 0 var(--button-padding-x);
  font-size: var(--button-font-size);
}
```

This pattern allows consumers to override specific values without modifying the base styles, and makes the relationship between size variants explicit and maintainable.

<Guideline type="do">
  Define component-level variables for dimensions, spacing, and typography that
  vary by size or variant.
</Guideline>

<Guideline type="do">
  Prefer dedicated CSS custom properties over `calc()` expressions for variant
  values. Instead of `calc(var(--base-width) + 1px)`, define `--base-width-md`
  directly.
</Guideline>

<Guideline type="dont">
  Use magic numbers directly in property values — always reference a design
  token or component variable.
</Guideline>

<Guideline type="dont">
  Use `calc()` expressions for simple size variations — define separate custom
  properties for each variant size.
</Guideline>

### Styling with SCSS

All components in the Zen Design System should use SCSS (`.scss` files) for styling. SCSS provides essential features for building maintainable, responsive components.

**Required SCSS Features:**

1. **Responsive Prop Mixins** - Use the `responsive-prop` mixin to automatically generate all media queries and fallback chains for responsive props:

```scss
@use '../../styles/mixins/responsive' as *;

.zen-component {
  /* Base styles */
}

/* Automatically generates all breakpoints and fallback chains */
@include responsive-prop('zen-component', 'padding', 'padding');
@include responsive-prop('zen-component', 'gap', 'gap');
```

The mixin automatically generates:

- Base styles (no media query)
- Media queries for each breakpoint (xs, sm, md, lg)
- Properly nested `var()` fallback chains for each breakpoint

2. **SCSS Variables** - Use SCSS variables from the design system for breakpoints and other shared values:

```scss
@use '../../styles/variables/breakpoints' as bp;

@media (min-width: bp.$breakpoints-sm) {
  /* Custom responsive styles if needed */
}
```

3. **Nesting** - Use SCSS nesting to organize related styles:

```scss
.zen-component {
  /* Base styles */

  &:hover {
    /* Hover styles */
  }

  &--variant {
    /* Variant styles */
  }
}
```

**When to Use SCSS Mixins vs Manual CSS:**

**Use the `responsive-prop` mixin** for all responsive props:

```scss
/* ✅ Use mixin - automatically generates all breakpoints */
@include responsive-prop('zen-component', 'padding', 'padding');
@include responsive-prop('zen-component', 'gap', 'gap');
```

**Write manual CSS** only for:

- Non-responsive styles (base component styles, variants, states)
- Custom responsive behavior that doesn't fit the standard pattern
- camelCase prop names that need manual handling (see Responsive Props section)

**Example: Manual CSS for camelCase props:**

```scss
@use '../../styles/variables/breakpoints' as bp;
@use 'sass:map';

/* For camelCase prop names, write CSS manually */
.zen-component[data-has-responsive-grid-template-areas='true'] {
  grid-template-areas: var(--component-gridTemplateAreas-base);
}

@media (min-width: map.get(bp.$breakpoints, 'xs')) {
  /* --breakpoint-xs: 480px */
  .zen-component[data-has-responsive-grid-template-areas='true'] {
    grid-template-areas: var(
      --component-gridTemplateAreas-xs,
      var(--component-gridTemplateAreas-base)
    );
  }
}

@media (min-width: map.get(bp.$breakpoints, 'sm')) {
  /* --breakpoint-sm: 640px */
  .zen-component[data-has-responsive-grid-template-areas='true'] {
    grid-template-areas: var(
      --component-gridTemplateAreas-sm,
      var(
        --component-gridTemplateAreas-xs,
        var(--component-gridTemplateAreas-base)
      )
    );
  }
}

@media (min-width: map.get(bp.$breakpoints, 'md')) {
  /* --breakpoint-md: 1024px */
  .zen-component[data-has-responsive-grid-template-areas='true'] {
    grid-template-areas: var(
      --component-gridTemplateAreas-md,
      var(
        --component-gridTemplateAreas-sm,
        var(
          --component-gridTemplateAreas-xs,
          var(--component-gridTemplateAreas-base)
        )
      )
    );
  }
}

@media (min-width: map.get(bp.$breakpoints, 'lg')) {
  /* --breakpoint-lg: 1280px */
  .zen-component[data-has-responsive-grid-template-areas='true'] {
    grid-template-areas: var(
      --component-gridTemplateAreas-lg,
      var(
        --component-gridTemplateAreas-md,
        var(
          --component-gridTemplateAreas-sm,
          var(
            --component-gridTemplateAreas-xs,
            var(--component-gridTemplateAreas-base)
          )
        )
      )
    );
  }
}
```

**SCSS File Organization:**

Structure your SCSS file with clear sections:

```scss
/* ============================================
   COMPONENT NAME
   ============================================ */

@use '../../styles/mixins/responsive' as *;

.zen-component {
  /* Base styles */
}

/* ----------------------------------------
   RESPONSIVE PROPS
   ---------------------------------------- */

@include responsive-prop('zen-component', 'padding', 'padding');
@include responsive-prop('zen-component', 'gap', 'gap');

/* ----------------------------------------
   VARIANTS
   ---------------------------------------- */

.zen-component--primary {
  /* Variant styles */
}

.zen-component--secondary {
  /* Variant styles */
}
```

The mixin automatically generates:

- Base styles (no media query)
- Media queries for each breakpoint (xs, sm, md, lg)
- Properly nested `var()` fallback chains for each breakpoint

### CSS Custom Property Naming Conventions

CSS custom properties follow a consistent naming pattern:

**Pattern:**

```
--{componentName}-{propName}-{breakpoint}
```

**Examples:**

- `--box-padding-base` (component: box, prop: padding, breakpoint: base)
- `--flex-gap-sm` (component: flex, prop: gap, breakpoint: sm)
- `--grid-columns-lg` (component: grid, prop: columns, breakpoint: lg)

**Rules:**

- Component name: lowercase, no hyphens (e.g., `box`, `flex`, `grid`)
- Prop name: matches the prop name exactly (camelCase preserved for camelCase props)
- Breakpoint: one of `base`, `xs`, `sm`, `md`, `lg`

**For camelCase props:**

- CSS custom property keeps camelCase: `--component-gridTemplateAreas-base`
- Data attribute uses kebab-case: `data-has-responsive-grid-template-areas`

### Data Attributes for Conditional CSS

Data attributes enable CSS rules to apply only when responsive props are actually used:

```css
/* Only applies when responsive padding is used */
.zen-component[data-has-responsive-padding='true'] {
  padding: var(--component-padding-base);
}
```

**Why this matters:**

- Prevents undefined CSS variable warnings
- Only applies responsive styles when needed
- Allows CSS to work with both simple and responsive prop values

**Pattern:**

```scss
@use '../../styles/variables/breakpoints' as bp;
@use 'sass:map';

/* Base rule - only applies with data attribute */
.zen-component[data-has-responsive-{prop-name}='true'] {
  {css-property}: var(--{component-name}-{prop-name}-base);
}

/* Media queries - only apply with data attribute */
@media (min-width: map.get(bp.$breakpoints, 'sm')) {
  /* --breakpoint-sm: 640px */
  .zen-component[data-has-responsive-{prop-name}='true'] {
    {css-property}: var(
      --{component-name}-{prop-name}-sm,
      var(--{component-name}-{prop-name}-base)
    );
  }
}
```

### Fallback Chains in CSS

CSS custom properties use nested `var()` functions to create fallback chains that inherit from smaller breakpoints:

```css
/* At sm breakpoint, try sm first, then xs, then base */
padding: var(
  --component-padding-sm,
  var(--component-padding-xs, var(--component-padding-base))
);
```

**How fallback chains work:**

1. Browser tries the first value (`--component-padding-sm`)
2. If undefined, falls back to the second value (`--component-padding-xs`)
3. If still undefined, falls back to the third value (`--component-padding-base`)

**Pattern for each breakpoint:**

- **base**: `var(--component-prop-base)`
- **xs**: `var(--component-prop-xs, var(--component-prop-base))`
- **sm**: `var(--component-prop-sm, var(--component-prop-xs, var(--component-prop-base)))`
- **md**: `var(--component-prop-md, var(--component-prop-sm, var(--component-prop-xs, var(--component-prop-base))))`
- **lg**: `var(--component-prop-lg, var(--component-prop-md, var(--component-prop-sm, var(--component-prop-xs, var(--component-prop-base)))))`

This ensures that if a breakpoint value isn't set, it inherits from the previous breakpoint.

### Interactive States

Always define states in this order:

1. Base styles
2. `:hover:not(:disabled)`
3. `:focus-visible`
4. `:active:not(:disabled)`
5. `:disabled`

```css
.zen-component {
  transition: background-color var(--transition-fast), color var(--transition-fast),
    border-color var(--transition-fast);
}

.zen-component:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--color-focus-ring);
}

.zen-component:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}
```

---

## Constants Handling

For components with multiple responsive props or complex CSS custom property usage, create a constants file to provide type safety and prevent typos.

### When to Create Constants

Create a constants file when:

- Your component has many responsive props (3+)
- You reference CSS custom properties in multiple places (component, tests, stories)
- You want type safety when referencing CSS variable names
- You have complex prop names that are easy to mistype

**Simple components** may not need a constants file. Use constants when they add value.

### Constants File Structure

Create a `{ComponentName}Constants.ts` file in your component directory (e.g., `ShojiGridConstants.ts` or `shojiGridConstants.ts`):

```tsx
/**
 * Typed constants for {ComponentName} CSS custom property names
 * These constants prevent typos and provide type safety when referencing CSS variables
 */

// Padding constants
export const {COMPONENT_NAME}_PADDING_BASE = '--{componentName}-padding-base'
export const {COMPONENT_NAME}_PADDING_XS = '--{componentName}-padding-xs'
export const {COMPONENT_NAME}_PADDING_SM = '--{componentName}-padding-sm'
export const {COMPONENT_NAME}_PADDING_MD = '--{componentName}-padding-md'
export const {COMPONENT_NAME}_PADDING_LG = '--{componentName}-padding-lg'

// Gap constants
export const {COMPONENT_NAME}_GAP_BASE = '--{componentName}-gap-base'
export const {COMPONENT_NAME}_GAP_XS = '--{componentName}-gap-xs'
export const {COMPONENT_NAME}_GAP_SM = '--{componentName}-gap-sm'
export const {COMPONENT_NAME}_GAP_MD = '--{componentName}-gap-md'
export const {COMPONENT_NAME}_GAP_LG = '--{componentName}-gap-lg'

// For camelCase prop names, keep camelCase in constant name
export const {COMPONENT_NAME}_GRID_TEMPLATE_AREAS_BASE =
  '--{componentName}-gridTemplateAreas-base'
export const {COMPONENT_NAME}_GRID_TEMPLATE_AREAS_XS =
  '--{componentName}-gridTemplateAreas-xs'
export const {COMPONENT_NAME}_GRID_TEMPLATE_AREAS_SM =
  '--{componentName}-gridTemplateAreas-sm'
export const {COMPONENT_NAME}_GRID_TEMPLATE_AREAS_MD =
  '--{componentName}-gridTemplateAreas-md'
export const {COMPONENT_NAME}_GRID_TEMPLATE_AREAS_LG =
  '--{componentName}-gridTemplateAreas-lg'
```

### Naming Conventions

**Constant names:**

- Use `UPPER_SNAKE_CASE`
- Prefix with component name in uppercase with underscores: `{COMPONENT_NAME}_` (e.g., `SHOJI_GRID_`, `BOX_`, `FLEX_`)
- Use descriptive prop name: `PADDING`, `GAP`, `GRID_TEMPLATE_AREAS`
- Include breakpoint: `BASE`, `XS`, `SM`, `MD`, `LG`

**Examples:**

- `{COMPONENT_NAME}_PADDING_BASE` → `'--{componentName}-padding-base'` (e.g., `SHOJI_GRID_COLUMNS_BASE` → `'--shoji-grid-columns-base'`)
- `{COMPONENT_NAME}_GAP_MD` → `'--{componentName}-gap-md'` (e.g., `SHOJI_GRID_GAP_MD` → `'--shoji-grid-gap-md'`)
- `{COMPONENT_NAME}_GRID_TEMPLATE_AREAS_SM` → `'--{componentName}-gridTemplateAreas-sm'` (e.g., `SHOJI_GRID_GRID_TEMPLATE_AREAS_SM` → `'--shoji-grid-gridTemplateAreas-sm'`)

### Using Constants

**In component files:**

```tsx
import { {COMPONENT_NAME}_PADDING_BASE, {COMPONENT_NAME}_GAP_MD } from './{ComponentName}Constants'

// Use constants when you need to reference CSS custom properties
const basePadding = getComputedStyle(element).getPropertyValue(
  {COMPONENT_NAME}_PADDING_BASE,
)
```

**In test files:**

```tsx
import { {COMPONENT_NAME}_PADDING_BASE, {COMPONENT_NAME}_GAP_MD } from './{ComponentName}Constants'

it('should set correct CSS custom properties', () => {
  const { container } = render(
    <ComponentName padding={{ base: 'sm', md: 'lg' }} />,
  )
  const element = container.querySelector('.zen-component') as HTMLElement

  const baseValue = getComputedStyle(element).getPropertyValue(
    {COMPONENT_NAME}_PADDING_BASE,
  )
  expect(baseValue.trim()).toBe('var(--space-2)')
})
```

**In CSS/SCSS files:**

Constants are TypeScript-only. In CSS, use the string values directly:

```scss
.zen-component[data-has-responsive-padding='true'] {
  padding: var(--component-padding-base); // Use string directly in CSS
}
```

### Benefits

**Type Safety:**

- TypeScript will catch typos at compile time
- IDE autocomplete helps find the right constant
- Refactoring is safer (rename constant, not strings)

**Maintainability:**

- Single source of truth for CSS custom property names
- Easy to find all usages of a CSS variable
- Clear documentation of which CSS variables exist

**Example without constants (error-prone):**

```tsx
// Easy to make typos
const value = getComputedStyle(el).getPropertyValue('--component-paddng-base') // typo!
```

**Example with constants (type-safe):**

```tsx
// TypeScript catches the error
const value = getComputedStyle(el).getPropertyValue(COMPONENT_PADDNG_BASE) // Error: doesn't exist
```

### Integration with Responsive Props

Constants work seamlessly with responsive props. The constants represent the CSS custom property names that `processResponsiveProps` generates:

```tsx
// TypeScript generates these CSS custom properties:
processResponsiveProps('component', {
  padding: normalizeResponsivePadding(padding),
})
// Generates: --component-padding-base, --component-padding-xs, etc.

// Constants provide type-safe access to these names:
import { {COMPONENT_NAME}_PADDING_BASE } from './{ComponentName}Constants'
const value = getComputedStyle(element).getPropertyValue({COMPONENT_NAME}_PADDING_BASE)
```

---

## Responsive Props

All visual props in Zen Design should be responsive, allowing them to accept different values at different breakpoints. This enables components to adapt seamlessly to different screen sizes without writing custom CSS.

### Understanding Responsive Props

Every prop type `T` can be extended to accept `T | { base?: T, xs?: T, sm?: T, md?: T, lg?: T }`:

```tsx
// Simple value (applies to all breakpoints)
<Box padding="md" />

// Responsive object (different values per breakpoint)
<Box padding={{ base: 'xs', sm: 'md', lg: 'xl' }} />
```

See the [Breakpoints documentation](/docs/foundations-breakpoints--docs) for complete details on the breakpoint system.

### Making Props Responsive

All visual props should use the `Responsive<T>` type to support responsive values:

```tsx
import type { Responsive } from '../../utils/Responsive'

export interface ComponentNameProps extends HTMLAttributes<HTMLDivElement> {
  /** Padding that adapts to screen size */
  padding?: Responsive<'xs' | 'sm' | 'md' | 'lg' | 'xl'>
  /** Gap between items */
  gap?: Responsive<string>
}
```

### Implementation Pattern

Follow this pattern to implement responsive props:

#### 1. Import Required Utilities

```tsx
import type { Responsive, ResponsiveObject } from '../../utils/Responsive'
import { isResponsiveObject } from '../../utils/Responsive'
import { processResponsiveProps } from '../../utils/responsiveProps'
```

#### 2. Normalize Values (if needed)

If your prop accepts a union type that needs conversion to CSS values, you need to normalize it. Use the `createNormalizeResponsive` utility to create a normalization function:

```tsx
import { createNormalizeResponsive } from '../../utils/normalizeResponsive'

type ComponentGap = 'none' | 'xs' | 'sm' | 'md' | 'lg'

// First, create a function that converts a single value to CSS
function gapToCSS(gap: ComponentGap): string {
  const mapping: Record<ComponentGap, string> = {
    none: '0',
    xs: 'var(--space-1)',
    sm: 'var(--space-2)',
    md: 'var(--space-4)',
    lg: 'var(--space-6)',
  }
  return mapping[gap]
}

// Then use createNormalizeResponsive to create the responsive normalization function
const normalizeResponsiveGap = createNormalizeResponsive(gapToCSS)
```

**When to use normalization:**

- **Use normalization** when your prop accepts semantic values (like `'sm'`, `'md'`, `'lg'`) that need to be converted to CSS values (like `'var(--space-2)'`)
- **Skip normalization** when your prop already accepts CSS values directly (like `string` for `gridTemplateRows`)

**Example without normalization (direct CSS values):**

```tsx
// For props that accept CSS values directly, no normalization needed
export interface ComponentNameProps {
  gridTemplateRows?: Responsive<string> // Already a CSS value
}

// In component:
const responsiveStyles = processResponsiveProps('component', {
  gridTemplateRows: gridTemplateRows, // Use directly
})
```

**Example with normalization (semantic values):**

```tsx
// For props that accept semantic values, normalize first
export interface ComponentNameProps {
  gap?: Responsive<'none' | 'sm' | 'md'> // Semantic values
}

// In component:
const responsiveStyles = processResponsiveProps('component', {
  gap: normalizeResponsiveGap(gap), // Normalize first
})
```

#### 3. Process Responsive Props

In your component, process responsive props and generate CSS custom properties:

```tsx
import { generateResponsiveDataAttributes } from '../../utils/responsiveDataAttributes'

export const ComponentName = forwardRef<HTMLDivElement, ComponentNameProps>(
  (
    {
      padding,
      gap,
      gridTemplateAreas,
      className = '',
      style,
      children,
      ...props
    },
    ref,
  ) => {
    // Process responsive props to CSS custom properties
    const responsiveStyles = processResponsiveProps('component', {
      padding: normalizeResponsivePadding(padding),
      gap: normalizeResponsiveGap(gap),
      gridTemplateAreas:
        normalizeResponsiveGridTemplateAreas(gridTemplateAreas),
    })

    // Generate data attributes automatically using the utility
    const dataAttributes = generateResponsiveDataAttributes({
      padding,
      gap,
    })

    // For camelCase prop names, manually add data attributes using kebab-case
    if (gridTemplateAreas && isResponsiveObject(gridTemplateAreas)) {
      dataAttributes['data-has-responsive-grid-template-areas'] = 'true'
    }

    return (
      <div
        ref={ref}
        className={className}
        style={{ ...responsiveStyles, ...style }}
        {...dataAttributes}
        {...props}
      >
        {children}
      </div>
    )
  },
)
```

**Handling camelCase prop names:**

When your prop name is camelCase (like `gridTemplateAreas`), the CSS custom property will use the camelCase name, but data attributes should use kebab-case:

```tsx
// CSS custom property: --component-gridTemplateAreas-base (keeps camelCase)
// Data attribute: data-has-responsive-grid-template-areas (use kebab-case directly)

if (gridTemplateAreas && isResponsiveObject(gridTemplateAreas)) {
  dataAttributes['data-has-responsive-grid-template-areas'] = 'true'
  // Results in: data-has-responsive-grid-template-areas="true"
}
```

#### 3.5. Custom Processing Functions for Special Props

Sometimes a prop needs special handling beyond normalization. For example, a `columns` prop that accepts both numbers and special values like `'auto-fill'` or `'auto-fit'` may need custom conversion logic.

**When to create a custom processing function:**

- Your prop accepts multiple types that need different conversion logic (e.g., `number | 'auto-fill' | 'auto-fit'`)
- The conversion logic is more complex than a simple mapping
- You need to generate CSS custom properties with a different pattern than `processResponsiveProps` provides

**Example: Custom processing for columns prop**

```tsx
type ComponentColumns = number | 'auto-fill' | 'auto-fit'

/**
 * Convert ComponentColumns to grid-template-columns CSS value
 */
function columnsToCSS(columns: ComponentColumns): string {
  if (typeof columns === 'number') {
    return `repeat(${columns}, 1fr)`
  }
  return `repeat(${columns}, minmax(200px, 1fr))`
}

/**
 * Process responsive columns into CSS custom properties
 * This is a custom function because columns needs special conversion logic
 */
function processResponsiveColumns(
  columns: Responsive<ComponentColumns> | undefined,
): Record<string, string> {
  const cssProps: Record<string, string> = {}

  if (columns === undefined) return cssProps

  if (isResponsiveObject(columns)) {
    if (columns.base !== undefined) {
      cssProps['--component-columns-base'] = columnsToCSS(columns.base)
    }
    for (const breakpoint of ['xs', 'sm', 'md', 'lg'] as const) {
      if (columns[breakpoint] !== undefined) {
        cssProps[`--component-columns-${breakpoint}`] = columnsToCSS(
          columns[breakpoint],
        )
      }
    }
  } else {
    cssProps['--component-columns-base'] = columnsToCSS(columns)
  }

  return cssProps
}

// In your component:
const responsiveStyles = processResponsiveProps('component', {
  gap: normalizeResponsiveGap(gap),
  // ... other standard props
})

// Handle columns separately with custom processing
if (!gridTemplateColumns) {
  const columnsStyles = processResponsiveColumns(columns)
  Object.assign(responsiveStyles, columnsStyles)
}
```

**Guidelines for custom processing functions:**

- Follow the same pattern as `processResponsiveProps`: handle both simple values and responsive objects
- Generate CSS custom properties following the naming convention: `--{componentName}-{propName}-{breakpoint}`
- Return a `Record<string, string>` that can be merged with other responsive styles
- Only create custom functions when necessary - prefer normalization and `processResponsiveProps` when possible

#### 4. Add CSS with Media Queries

Create CSS rules that use CSS custom properties with fallback chains. You can use SCSS mixins to generate this automatically, or write it manually in CSS.

**Using SCSS Mixins (Recommended):**

If you're using SCSS, use the `responsive-prop` mixin to generate all media queries and fallback chains automatically:

```scss
@use '../../styles/mixins/responsive' as *;

.zen-component {
  /* Base component styles */
}

/* Responsive padding - automatically generates all breakpoints and fallback chains */
@include responsive-prop('zen-component', 'padding', 'padding');

/* Responsive gap */
@include responsive-prop('zen-component', 'gap', 'gap');
```

The mixin automatically generates:

- Base styles (no media query)
- Media queries for each breakpoint (xs, sm, md, lg)
- Properly nested `var()` fallback chains for each breakpoint

**Manual CSS (if not using SCSS):**

If you're using plain CSS, write the media queries manually:

```css
/* Responsive padding */
/* Only applies when data-has-responsive-padding attribute is present */
.zen-component[data-has-responsive-padding='true'] {
  padding: var(--component-padding-base);
}

@media (min-width: 480px) {
  /* --breakpoint-xs: 480px */
  .zen-component[data-has-responsive-padding='true'] {
    padding: var(--component-padding-xs, var(--component-padding-base));
  }
}

@media (min-width: 640px) {
  /* --breakpoint-sm: 640px */
  .zen-component[data-has-responsive-padding='true'] {
    padding: var(
      --component-padding-sm,
      var(--component-padding-xs, var(--component-padding-base))
    );
  }
}

@media (min-width: 1024px) {
  /* --breakpoint-md: 1024px */
  .zen-component[data-has-responsive-padding='true'] {
    padding: var(
      --component-padding-md,
      var(
        --component-padding-sm,
        var(--component-padding-xs, var(--component-padding-base))
      )
    );
  }
}

@media (min-width: 1280px) {
  /* --breakpoint-lg: 1280px */
  .zen-component[data-has-responsive-padding='true'] {
    padding: var(
      --component-padding-lg,
      var(
        --component-padding-md,
        var(
          --component-padding-sm,
          var(--component-padding-xs, var(--component-padding-base))
        )
      )
    );
  }
}
```

**For camelCase prop names in SCSS:**

When using camelCase prop names (like `gridTemplateAreas`), write the CSS manually since the mixin expects kebab-case:

```scss
/* Responsive grid-template-areas (camelCase prop name) */
.zen-component[data-has-responsive-grid-template-areas='true'] {
  grid-template-areas: var(--component-gridTemplateAreas-base);
}

@media (min-width: 480px) {
  .zen-component[data-has-responsive-grid-template-areas='true'] {
    grid-template-areas: var(
      --component-gridTemplateAreas-xs,
      var(--component-gridTemplateAreas-base)
    );
  }
}

/* ... continue for other breakpoints */
```

### Key Implementation Details

**1. Data Attributes**

Always add data attributes when responsive props are used. This ensures CSS rules only apply when the CSS custom properties actually exist, preventing undefined variable warnings.

**Using the utility (recommended):**

```tsx
import { generateResponsiveDataAttributes } from '../../utils/responsiveDataAttributes'

// Automatically generates data attributes for all responsive props
const dataAttributes = generateResponsiveDataAttributes({
  padding,
  gap,
  columns,
})
```

**Manual approach (for camelCase props or custom logic):**

```tsx
const dataAttributes: Record<string, string> = {}
if (padding && isResponsiveObject(padding)) {
  dataAttributes['data-has-responsive-padding'] = 'true'
}
if (gap && isResponsiveObject(gap)) {
  dataAttributes['data-has-responsive-gap'] = 'true'
}
```

**2. CSS Custom Property Naming**

CSS custom properties follow this pattern:

```
--{componentName}-{propName}-{breakpoint}
```

Examples:

- `--box-padding-base`
- `--flex-gap-sm`
- `--grid-columns-lg`

**3. Fallback Chains**

Use nested `var()` functions to create fallback chains that inherit from smaller breakpoints:

```css
/* At sm breakpoint, try sm first, then xs, then base */
padding: var(
  --component-padding-sm,
  var(--component-padding-xs, var(--component-padding-base))
);
```

**4. Component Name Parameter**

The first parameter to `processResponsiveProps` should be the component name (lowercase, kebab-case with hyphens allowed for multi-word components):

```tsx
processResponsiveProps('box', { padding: ... })        // ✅ Correct (single word)
processResponsiveProps('shoji-grid', { gap: ... })     // ✅ Correct (multi-word, kebab-case)
processResponsiveProps('zen-box', { padding: ... })    // ❌ Wrong (includes 'zen-' prefix)
processResponsiveProps('Box', { padding: ... })        // ❌ Wrong (capitalized)
processResponsiveProps('shojiGrid', { gap: ... })     // ❌ Wrong (camelCase, should be kebab-case)
```

### Backward Compatibility

Responsive props maintain backward compatibility with simple values. If a user passes a simple value, it works exactly as before:

```tsx
// Both work identically for non-responsive usage
<Box padding="md" />
<Box padding={{ base: 'md' }} />
```

#### Maintaining Class Names with Responsive Props

When your component has existing CSS that relies on class names (e.g., variant styles, size modifiers), you should maintain class names for the base value even when using responsive props. This allows existing CSS rules to continue working:

```tsx
/**
 * Get class name for a prop
 * For responsive objects, returns the base value's class name
 * For simple values, returns the value's class name
 * This allows existing CSS (like variant styles) to work with responsive props
 */
function getGapClassName(
  value: Responsive<ComponentGap> | undefined,
): string | false {
  if (!value) return false

  if (isResponsiveObject(value)) {
    // For responsive objects, use the base value for the class name
    // This allows variant styles to work with responsive props at the base breakpoint
    return value.base !== undefined ? `zen-component--gap-${value.base}` : false
  }

  return `zen-component--gap-${value}`
}

// In your component:
const classNames = [
  'zen-component',
  getGapClassName(gap), // Always adds base class, even for responsive props
  className,
]
  .filter(Boolean)
  .join(' ')
```

**Why this matters:**

- Existing CSS rules that target class names (e.g., `.zen-shoji-grid--gap-md`) continue to work
- The base breakpoint uses the class name, while responsive breakpoints use CSS custom properties
- You can add data attributes for breakpoint-specific values to enable more complex CSS rules

**When to use breakpoint-specific data attributes:**

Breakpoint-specific data attributes (e.g., `data-gap-base`, `data-gap-md`) are useful when:

- You need CSS rules that vary based on the specific breakpoint value (not just whether it's responsive)
- You want to write CSS that targets specific prop values at specific breakpoints
- Your component has variant styles that need to respond to breakpoint-specific prop values
- You need to create complex CSS selectors that combine breakpoint data attributes with other selectors

**Example: Using breakpoint-specific data attributes**

```tsx
// Add data attributes for breakpoint-specific values
if (gap && isResponsiveObject(gap)) {
  dataAttributes['data-has-responsive-gap'] = 'true'
  if (gap.base !== undefined) {
    dataAttributes['data-gap-base'] = gap.base
  }
  if (gap.xs !== undefined) {
    dataAttributes['data-gap-xs'] = gap.xs
  }
  if (gap.sm !== undefined) {
    dataAttributes['data-gap-sm'] = gap.sm
  }
  if (gap.md !== undefined) {
    dataAttributes['data-gap-md'] = gap.md
  }
  if (gap.lg !== undefined) {
    dataAttributes['data-gap-lg'] = gap.lg
  }
}
```

This enables CSS rules like:

```css
/* Apply different frame widths based on gap value at md breakpoint */
.zen-component[data-has-responsive-gap='true'][data-gap-md='md'] {
  --frame-width: var(--frame-width-md);
}
```

This pattern allows you to write CSS that works with both class names and responsive props. **Prefer defining dedicated CSS custom properties instead of using `calc()` expressions:**

```css
/* Define all size variants as custom properties in the base variant */
.component--variant {
  --frame-width: 3px;
  --frame-width-md: 4px;
  --frame-width-lg: 5px;
  --frame-width-xl: 6px;
}

/* Works with class name (base breakpoint) */
.component--variant.component--gap-md {
  gap: var(--frame-width-md);
}

/* Works with responsive props (all breakpoints) */
.component--variant[data-has-responsive-gap='true'][data-gap-md='md'] {
  gap: var(--frame-width-md);
}
```

This approach makes values easier to customize, reduces computation, and improves maintainability compared to using `calc()` expressions.

**5. TypeScript Constants for CSS Custom Properties**

For complex components with many responsive props, consider creating a constants file with typed CSS custom property names. This prevents typos and provides type safety:

```tsx
// {ComponentName}Constants.ts
export const {COMPONENT_NAME}_PADDING_BASE = '--{componentName}-padding-base'
export const {COMPONENT_NAME}_PADDING_XS = '--{componentName}-padding-xs'
export const {COMPONENT_NAME}_PADDING_SM = '--{componentName}-padding-sm'
export const {COMPONENT_NAME}_PADDING_MD = '--{componentName}-padding-md'
export const {COMPONENT_NAME}_PADDING_LG = '--{componentName}-padding-lg'

export const {COMPONENT_NAME}_GAP_BASE = '--{componentName}-gap-base'
export const {COMPONENT_NAME}_GAP_XS = '--{componentName}-gap-xs'
// ... etc
```

Then use these constants when referencing CSS custom properties in your code:

```tsx
// In component or test files
const baseValue = getComputedStyle(element).getPropertyValue(
  {COMPONENT_NAME}_PADDING_BASE,
)
```

**Note for Compound Components:** When sub-components extend other component props (like `BoxProps`), they should use the parent component's CSS prefix in `processResponsiveProps`. For example, a `GridCell` component that extends `BoxProps` should use `'box'` as the prefix, allowing it to reuse Box CSS rules.

### Best Practices

<Guideline type="do">
  Make all visual props responsive (padding, margin, gap, columns, sizes, etc.)
</Guideline>

<Guideline type="do">
  Use data attributes to conditionally apply CSS rules
</Guideline>

<Guideline type="do">
  Define dedicated CSS custom properties for size variants instead of using
  `calc()` expressions (e.g., `--component-size-md: 4px` instead of
  `calc(var(--component-size) + 1px)`)
</Guideline>

<Guideline type="do">
  Add comments in CSS referencing breakpoint tokens
</Guideline>

<Guideline type="dont">
  Make event handlers, refs, or children responsive
</Guideline>

<Guideline type="dont">
  Create responsive props for non-visual props (event handlers, refs, children,
  etc.)
</Guideline>

---

## Testing

Comprehensive testing ensures your component works correctly across all scenarios. Use Vitest and React Testing Library for component testing.

### Testing Framework Setup

**Required dependencies:**

```json
{
  "devDependencies": {
    "vitest": "^1.0.0",
    "@testing-library/react": "^14.0.0",
    "@testing-library/jest-dom": "^6.0.0"
  }
}
```

**Test file structure:**

Create a `ComponentName.test.tsx` file in your component directory:

```tsx
import { describe, it, expect } from 'vitest'
import { render } from '@testing-library/react'
import { ComponentName } from './ComponentName'

describe('ComponentName', () => {
  // Test cases here
})
```

### What to Test

#### 1. Component Rendering

Test that your component renders correctly with basic props:

```tsx
it('should render with children', () => {
  const { getByText } = render(<ComponentName>Test Content</ComponentName>)
  expect(getByText('Test Content')).toBeInTheDocument()
})

it('should render with default props', () => {
  const { container } = render(<ComponentName />)
  const element = container.querySelector('.zen-component')
  expect(element).toBeInTheDocument()
})
```

#### 2. CSS Custom Properties

Test that responsive props generate the correct CSS custom properties:

```tsx
it('should set correct CSS custom properties for responsive props', () => {
  const { container } = render(
    <ComponentName padding={{ base: 'sm', md: 'lg' }} />,
  )
  const element = container.querySelector('.zen-component') as HTMLElement

  // Check base value
  const baseValue = getComputedStyle(element).getPropertyValue(
    '--component-padding-base',
  )
  expect(baseValue.trim()).toBe('var(--space-2)')

  // Check md value
  const mdValue = getComputedStyle(element).getPropertyValue(
    '--component-padding-md',
  )
  expect(mdValue.trim()).toBe('var(--space-6)')
})
```

**Using constants (recommended):**

```tsx
import {
  {COMPONENT_NAME}_PADDING_BASE,
  {COMPONENT_NAME}_PADDING_MD,
} from './{ComponentName}Constants'

it('should set correct CSS custom properties', () => {
  const { container } = render(
    <ComponentName padding={{ base: 'sm', md: 'lg' }} />,
  )
  const element = container.querySelector('.zen-component') as HTMLElement

  const baseValue = getComputedStyle(element).getPropertyValue(
    {COMPONENT_NAME}_PADDING_BASE,
  )
  expect(baseValue.trim()).toBe('var(--space-2)')
})
```

#### 3. Data Attributes

Test that data attributes are set correctly for responsive props:

```tsx
it('should set data-has-responsive-padding attribute when using responsive padding', () => {
  const { container } = render(
    <ComponentName padding={{ base: 'sm', md: 'lg' }} />,
  )
  const element = container.querySelector('.zen-component')

  expect(element).toHaveAttribute('data-has-responsive-padding', 'true')
})

it('should not set data attribute for simple (non-responsive) values', () => {
  const { container } = render(<ComponentName padding="sm" />)
  const element = container.querySelector('.zen-component')

  expect(element).not.toHaveAttribute('data-has-responsive-padding')
})
```

#### 4. Responsive Behavior

Test that responsive props work correctly at different breakpoints:

```tsx
it('should apply correct values at base breakpoint', () => {
  const { container } = render(<ComponentName gap={{ base: 'sm', md: 'md' }} />)
  const element = container.querySelector('.zen-component') as HTMLElement

  const baseValue = getComputedStyle(element).getPropertyValue(
    '--component-gap-base',
  )
  expect(baseValue.trim()).toBe('var(--grid-gap-sm)')
})

it('should set breakpoint-specific values', () => {
  const { container } = render(<ComponentName gap={{ base: 'sm', md: 'md' }} />)
  const element = container.querySelector('.zen-component') as HTMLElement

  const mdValue =
    getComputedStyle(element).getPropertyValue('--component-gap-md')
  expect(mdValue.trim()).toBe('var(--grid-gap-md)')
})
```

#### 5. CSS Variable Resolution

Test that CSS variables resolve correctly (when tokens are loaded):

```tsx
it('should have root-level tokens defined with correct values', () => {
  const rootStyles = getComputedStyle(document.documentElement)

  const spaceSm = rootStyles.getPropertyValue('--space-2')
  const spaceLg = rootStyles.getPropertyValue('--space-6')

  expect(spaceSm.trim()).toBe('0.5rem') // Adjust to your actual token values
  expect(spaceLg.trim()).toBe('1.5rem')
})

it('should set component-level variables that reference root tokens', () => {
  const { container } = render(
    <ComponentName padding={{ base: 'sm', md: 'lg' }} />,
  )
  const element = container.querySelector('.zen-component') as HTMLElement
  const elementStyles = getComputedStyle(element)

  const baseValue = elementStyles.getPropertyValue('--component-padding-base')
  expect(baseValue.trim()).toBe('var(--space-2)')

  // Verify root token exists
  const rootStyles = getComputedStyle(document.documentElement)
  const rootSpaceSm = rootStyles.getPropertyValue('--space-2')
  expect(rootSpaceSm.trim()).toBe('0.5rem')
})
```

#### 6. Component Props and Variants

Test that all props and variants work correctly:

```tsx
it('should apply variant class correctly', () => {
  const { container } = render(<ComponentName variant="primary" />)
  const element = container.querySelector('.zen-component')

  expect(element).toHaveClass('zen-component--primary')
})

it('should apply size class correctly', () => {
  const { container } = render(<ComponentName size="lg" />)
  const element = container.querySelector('.zen-component')

  expect(element).toHaveClass('zen-component--lg')
})

it('should handle disabled state', () => {
  const { container } = render(<ComponentName disabled />)
  const element = container.querySelector('.zen-component')

  expect(element).toHaveAttribute('aria-disabled', 'true')
})
```

#### 7. Normalization Functions

Test that normalization functions convert values correctly:

```tsx
import { normalizeResponsiveGap } from './ComponentName'

describe('normalizeResponsiveGap', () => {
  it('should convert simple value to CSS', () => {
    const result = normalizeResponsiveGap('sm')
    expect(result).toBe('var(--grid-gap-sm)')
  })

  it('should convert responsive object to CSS values', () => {
    const result = normalizeResponsiveGap({ base: 'sm', md: 'md' })
    expect(result).toEqual({
      base: 'var(--grid-gap-sm)',
      md: 'var(--grid-gap-md)',
    })
  })

  it('should return undefined for undefined input', () => {
    const result = normalizeResponsiveGap(undefined)
    expect(result).toBeUndefined()
  })
})
```

#### 8. Compound Components

Test compound components (components with sub-components):

```tsx
it('should render compound component correctly', () => {
  const { container } = render(
    <ComponentName>
      <ComponentName.Item>Item 1</ComponentName.Item>
      <ComponentName.Item>Item 2</ComponentName.Item>
    </ComponentName>,
  )

  const items = container.querySelectorAll('.zen-component-item')
  expect(items).toHaveLength(2)
})

it('should apply props to sub-components', () => {
  const { container } = render(
    <ComponentName>
      <ComponentName.Item area="header">Header</ComponentName.Item>
    </ComponentName>,
  )

  const item = container.querySelector('.zen-component-item') as HTMLElement
  const style = getComputedStyle(item)
  expect(style.gridArea).toBe('header')
})
```

### How to Test

#### Testing CSS Custom Properties

Use `getComputedStyle` to read CSS custom properties:

```tsx
const element = container.querySelector('.zen-component') as HTMLElement
const styles = getComputedStyle(element)

// Read a CSS custom property
const paddingBase = styles.getPropertyValue('--component-padding-base')
expect(paddingBase.trim()).toBe('var(--space-2)')
```

**Note:** In jsdom (Vitest's default environment), CSS variables don't fully resolve. You can verify that:

- CSS custom properties are set correctly
- Data attributes are present
- The structure is correct

For full CSS variable resolution testing, use a browser-based test environment or Storybook.

#### Testing Data Attributes

Use React Testing Library's `toHaveAttribute` matcher:

```tsx
expect(element).toHaveAttribute('data-has-responsive-padding', 'true')
expect(element).toHaveAttribute('data-gap-base', 'sm')
```

#### Testing Responsive Behavior

Test responsive behavior by verifying:

1. CSS custom properties are set for each breakpoint
2. Data attributes indicate responsive usage
3. Fallback chains are structured correctly

```tsx
it('should have correct fallback chain structure', () => {
  const { container } = render(<ComponentName gap={{ base: 'sm', md: 'md' }} />)
  const element = container.querySelector('.zen-component') as HTMLElement

  // Verify base is set
  const base = getComputedStyle(element).getPropertyValue(
    '--component-gap-base',
  )
  expect(base.trim()).toBe('var(--grid-gap-sm)')

  // Verify md is set (will fallback to base if not set)
  const md = getComputedStyle(element).getPropertyValue('--component-gap-md')
  expect(md.trim()).toBe('var(--grid-gap-md)')

  // Verify xs is not set (should be empty)
  const xs = getComputedStyle(element).getPropertyValue('--component-gap-xs')
  expect(xs.trim()).toBe('')
})
```

#### Testing Utilities and Helpers

Create helper functions for common test patterns:

```tsx
// test-utils.tsx
export function getComponentStyles(container: HTMLElement, selector: string) {
  const element = container.querySelector(selector) as HTMLElement
  return getComputedStyle(element)
}

export function getCSSVariable(
  container: HTMLElement,
  selector: string,
  variable: string,
): string {
  const styles = getComponentStyles(container, selector)
  return styles.getPropertyValue(variable).trim()
}

// Usage in tests:
it('should set padding correctly', () => {
  const { container } = render(<ComponentName padding="sm" />)
  const padding = getCSSVariable(
    container,
    '.zen-component',
    '--component-padding-base',
  )
  expect(padding).toBe('var(--space-2)')
})
```

### Testing Best Practices

<Guideline type="do">
  Test CSS custom properties are set correctly for responsive props
</Guideline>

<Guideline type="do">
  Test data attributes are applied when responsive props are used
</Guideline>

<Guideline type="do">
  Test normalization functions separately from component rendering
</Guideline>

<Guideline type="do">Test both simple and responsive prop values</Guideline>

<Guideline type="do">
  Use constants for CSS custom property names in tests
</Guideline>

<Guideline type="dont">
  Test CSS variable resolution in jsdom (they don't fully resolve)
</Guideline>

<Guideline type="dont">
  Test media query behavior in unit tests (use Storybook or browser tests)
</Guideline>

<Guideline type="dont">
  Test implementation details - focus on behavior and output
</Guideline>

---

## Storybook Stories

### File Structure

```tsx
import type { Meta, StoryObj } from '@storybook/react'
import { ComponentName } from './ComponentName'

const meta: Meta<typeof ComponentName> = {
  title: 'Components/ComponentName',
  component: ComponentName,
  tags: ['autodocs'],
  parameters: {
    layout: 'fullscreen',
  },
  argTypes: {
    // Define controls for each prop
  },
}

export default meta
type Story = StoryObj<typeof ComponentName>
```

### Configuring ArgTypes

Provide meaningful controls and descriptions for each prop:

```tsx
argTypes: {
  variant: {
    control: 'select',
    options: ['primary', 'secondary', 'outline', 'ghost'],
    description: 'The visual style variant',
  },
  size: {
    control: 'select',
    options: ['sm', 'md', 'lg'],
    description: 'The size of the component',
  },
  disabled: {
    control: 'boolean',
    description: 'Whether the component is disabled',
  },
}
```

---

## Story Granularity

Stories should be **comprehensive but focused**. Each story should demonstrate
a specific aspect of the component.

### Playground Story (Required)

Every component **must** include a `Playground` story as the first story. This provides an interactive sandbox where developers can experiment with all props using Storybook controls.

```tsx
export const Playground: Story = {
  args: {
    children: 'Button',
    variant: 'primary',
    size: 'md',
    disabled: false,
  },
}
```

The Playground story should:

- Be the first exported story (appears at the top of the component's story list)
- Include sensible default values for all props via `args`
- Enable full interactivity through Storybook's Controls panel

### Using Design Tokens in Stories

Always use design tokens instead of hardcoded pixel or rem values in story layouts. This ensures visual consistency with the design system.

<Guideline type="do">

```tsx
<div style={{ display: 'flex', gap: 'var(--space-4)', alignItems: 'center' }}>
  <Button variant="primary">Primary</Button>
  <Button variant="secondary">Secondary</Button>
</div>
```

</Guideline>

<Guideline type="dont">

```tsx
<div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
  <Button variant="primary">Primary</Button>
  <Button variant="secondary">Secondary</Button>
</div>
```

</Guideline>

### Required Stories

Every component should include these essential stories:

<div
  style={{
    padding: '1.5rem',
    backgroundColor: 'var(--color-surface)',
    border: '1px solid var(--color-border-subtle)',
    borderRadius: 'var(--radius-md)',
    marginBottom: '1.5rem',
  }}
>
  <h4
    style={{
      margin: '0 0 1rem 0',
      fontSize: 'var(--font-size-base)',
      fontWeight: 'var(--font-weight-semibold)',
      color: 'var(--color-text-primary)',
    }}
  >
    Essential Stories Checklist
  </h4>
  <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>Playground</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Interactive sandbox with all props via args
      </span>
    </div>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>All Variants</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Shows each variant side by side
      </span>
    </div>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>All Sizes</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Shows each size side by side
      </span>
    </div>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>Disabled State</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Shows disabled state for each variant
      </span>
    </div>
  </div>
</div>

### Story Patterns

#### Composite Stories (Preferred for Visual Comparison)

Show multiple variations in a single story for easy visual comparison:

```tsx
export const AllVariants: Story = {
  name: 'All Variants',
  render: () => (
    <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
      <ComponentName variant="primary">Primary</ComponentName>
      <ComponentName variant="secondary">Secondary</ComponentName>
      <ComponentName variant="outline">Outline</ComponentName>
    </div>
  ),
}
```

#### State Stories

Group related states together:

```tsx
export const Disabled: Story = {
  render: () => (
    <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
      <ComponentName variant="primary" disabled>
        Primary
      </ComponentName>
      <ComponentName variant="secondary" disabled>
        Secondary
      </ComponentName>
      <ComponentName variant="outline" disabled>
        Outline
      </ComponentName>
    </div>
  ),
}
```

### When to Create Separate Stories

Create individual stories for:

- **Complex interactions** that need isolated testing
- **Edge cases** like very long content or unusual states
- **Responsive behavior** that needs viewport controls
- **Integration examples** showing component combinations

### Story Naming

Use clear, descriptive names with the `name` property:

```tsx
export const AllVariants: Story = {
  name: 'All Variants',
  // ...
}

export const WithLongContent: Story = {
  name: 'With Long Content',
  // ...
}
```

---

## Barrel Exports

The `index.ts` file should export the component and all its types:

```tsx
export { ComponentName } from './ComponentName'
export type {
  ComponentNameProps,
  ComponentVariant,
  ComponentSize,
} from './ComponentName'
```

---

## Compound Components

When a component has sub-components (e.g., `ComponentName.Item`), follow this pattern:

### File Structure

Extract sub-components to separate files when they:

- Have their own props interface
- Support responsive props independently
- Are complex enough to warrant separation

Example: `ComponentName` and `ComponentNameItem`

```
src/components/ComponentName/
├── ComponentName.tsx          # Main ComponentName component
├── ComponentNameItem.tsx     # ComponentName.Item sub-component
├── ComponentName.css
├── ComponentName.stories.tsx
└── index.ts
```

### Implementation Pattern

```tsx
// ComponentNameItem.tsx
export interface ComponentNameItemProps extends BoxProps {
  area?: string
  column?: string
  row?: string
}

export const ComponentNameItem = forwardRef<
  HTMLDivElement,
  ComponentNameItemProps
>(({ area, column, row, ...props }, ref) => {
  // Implementation with responsive props support
})

ComponentNameItem.displayName = 'ComponentName.Item'

// ComponentName.tsx
import { ComponentNameItem } from './ComponentNameItem'

const ComponentNameRoot = forwardRef<HTMLDivElement, ComponentNameProps>(
  ({ ...props }, ref) => {
    // Implementation
  },
)

ComponentNameRoot.displayName = 'ComponentName'

// Compound component pattern
export const ComponentName = Object.assign(ComponentNameRoot, {
  Item: ComponentNameItem,
})
```

### Export Pattern

```tsx
// index.ts
export { ComponentName } from './ComponentName'
export type { ComponentNameProps, ... } from './ComponentName'
export type { ComponentNameItemProps } from './ComponentNameItem'
```

### Responsive Props in Sub-Components

Sub-components that extend other component props (like `FlexProps`) should:

- Use the parent component's CSS prefix (e.g., 'flex' for components extending FlexProps)
- Support all responsive props from the parent interface
- Add data attributes for responsive props
- Only add class names for non-responsive values

```tsx
// GridCell uses 'flex' prefix since it extends FlexProps
const responsiveStyles = processResponsiveProps('flex', {
  gap: normalizeResponsiveGap(gap),
  direction: normalizeResponsiveDirection(direction),
  // ... other flex props
})
```

This allows sub-components to reuse the parent component's CSS rules while maintaining their own implementation.

---

## Checklist

Before submitting a new component, verify:

<div
  style={{
    padding: '1.5rem',
    backgroundColor: 'var(--color-surface)',
    border: '1px solid var(--color-border-subtle)',
    borderRadius: 'var(--radius-md)',
  }}
>
  <div
    style={{
      display: 'grid',
      gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
      gap: '1rem',
    }}
  >
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Implementation
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Uses <code>forwardRef</code> for DOM access
        </li>
        <li>Extends appropriate native HTML attributes</li>
        <li>Has JSDoc comments on all props</li>
        <li>
          Sets <code>displayName</code> for debugging
        </li>
        <li>Provides sensible default prop values</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Styling
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>Uses only design tokens (no hardcoded values)</li>
        <li>
          Has <code>zen-</code> prefix on all classes
        </li>
        <li>Defines all interactive states</li>
        <li>Includes focus-visible styles</li>
        <li>Has disabled state with proper cursor</li>
        <li>Uses SCSS mixins for responsive props (if using SCSS)</li>
        <li>Data attributes conditionally apply CSS rules</li>
        <li>CSS custom properties use proper naming conventions</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Responsive Props
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Uses <code>Responsive&lt;T&gt;</code> type for responsive props
        </li>
        <li>Normalizes semantic values to CSS (if needed)</li>
        <li>
          Uses <code>processResponsiveProps</code> to generate CSS custom
          properties
        </li>
        <li>Adds data attributes for responsive props</li>
        <li>Handles camelCase prop names correctly</li>
        <li>Maintains class names for backward compatibility</li>
        <li>CSS includes fallback chains for all breakpoints</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Constants
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>Constants file created (if component has 3+ responsive props)</li>
        <li>
          Constants use <code>UPPER_SNAKE_CASE</code> naming
        </li>
        <li>Constants match CSS custom property naming pattern</li>
        <li>Constants exported for use in tests and component</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Testing
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>Test file created with component tests</li>
        <li>Tests component rendering</li>
        <li>Tests CSS custom properties are set correctly</li>
        <li>Tests data attributes are applied</li>
        <li>Tests responsive prop behavior</li>
        <li>Tests normalization functions (if applicable)</li>
        <li>Tests component variants and props</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Storybook
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Has <code>Playground</code> story as first story
        </li>
        <li>
          Has <code>autodocs</code> tag enabled
        </li>
        <li>Includes stories for all variants</li>
        <li>Includes stories for all sizes</li>
        <li>Shows disabled states</li>
        <li>Uses design tokens in story layouts</li>
        <li>
          Has descriptive <code>argTypes</code>
        </li>
        <li>Passes a11y addon checks</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Exports
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Has barrel export in <code>index.ts</code>
        </li>
        <li>Exports component and all types</li>
        <li>Added to main library exports</li>
      </ul>
    </div>
  </div>
</div>

**Note:** Not all checklist items apply to every component. Use your judgment based on component complexity. For example:

- Simple components may not need constants files
- All components should have tests, but complexity varies
