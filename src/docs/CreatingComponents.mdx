{/* CreatingComponents.mdx */}
import { Meta } from '@storybook/blocks';

<Meta title="Guidelines/Creating Components" />

# Creating Components

A comprehensive guide to building components for the Zen Design System. Follow these
patterns to ensure consistency, maintainability, and a great developer experience.

export const FileCard = ({ name, description }) => (
  <div
    style={{
      display: 'flex',
      alignItems: 'flex-start',
      gap: '1rem',
      padding: '1rem',
      backgroundColor: 'var(--color-surface)',
      border: '1px solid var(--color-border-subtle)',
      borderRadius: 'var(--radius-md)',
      marginBottom: '0.5rem',
    }}
  >
    <code
      style={{
        padding: '0.25rem 0.5rem',
        backgroundColor: 'var(--color-primary-subtle)',
        color: 'var(--color-primary)',
        borderRadius: 'var(--radius-sm)',
        fontFamily: 'var(--font-family-mono)',
        fontSize: 'var(--font-size-sm)',
        whiteSpace: 'nowrap',
      }}
    >
      {name}
    </code>
    <span
      style={{
        fontSize: 'var(--font-size-sm)',
        color: 'var(--color-text-secondary)',
        lineHeight: 'var(--line-height-normal)',
      }}
    >
      {description}
    </span>
  </div>
)

export const Guideline = ({ type, children }) => {
  const colors = {
    do: {
      bg: 'var(--color-secondary-50)',
      border: 'var(--color-secondary-500)',
      label: '✓ Do',
    },
    dont: { bg: '#fef2f2', border: '#ef4444', label: "✗ Don't" },
  }
  const style = colors[type]
  return (
    <div
      style={{
        padding: '1rem',
        backgroundColor: style.bg,
        borderLeft: `4px solid ${style.border}`,
        borderRadius: 'var(--radius-md)',
        marginBottom: '0.75rem',
      }}
    >
      <div
        style={{
          fontWeight: 'var(--font-weight-semibold)',
          fontSize: 'var(--font-size-sm)',
          color: style.border,
          marginBottom: '0.5rem',
        }}
      >
        {style.label}
      </div>
      <div
        style={{
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-primary)',
        }}
      >
        {children}
      </div>
    </div>
  )
}

---

## File Structure

Each component should live in its own folder within `src/components/` with the
following structure:

<FileCard
  name="ComponentName.tsx"
  description="The main component implementation with TypeScript types and props interface."
/>
<FileCard
  name="ComponentName.css"
  description="Component-specific styles using CSS custom properties from design tokens."
/>
<FileCard
  name="ComponentName.stories.tsx"
  description="Storybook stories showcasing all variants, sizes, and states."
/>
<FileCard name="index.ts" description="Barrel export file for clean imports." />

### Example Structure

```
src/components/
└── ComponentName/
    ├── ComponentName.tsx
    ├── ComponentName.css
    ├── ComponentName.stories.tsx
    └── index.ts
```

---

## YAGNI Principle

**You Ain't Gonna Need It** — build only what is explicitly required.

The Zen Design System follows a minimal implementation philosophy. Before adding any feature or prop, ask yourself: "Is this explicitly requested or documented in the requirements?"

<div
  style={{
    padding: '1.5rem',
    backgroundColor: 'var(--color-surface)',
    border: '1px solid var(--color-border-subtle)',
    borderRadius: 'var(--radius-md)',
    marginBottom: '1.5rem',
  }}
>
  <h4
    style={{
      margin: '0 0 1rem 0',
      fontSize: 'var(--font-size-base)',
      fontWeight: 'var(--font-weight-semibold)',
      color: 'var(--color-text-primary)',
    }}
  >
    YAGNI Guidelines
  </h4>
  <ul
    style={{
      margin: 0,
      paddingLeft: '1.25rem',
      fontSize: 'var(--font-size-sm)',
      color: 'var(--color-text-secondary)',
      lineHeight: '1.8',
    }}
  >
    <li>Only add props or functionality that is explicitly requested</li>
    <li>Avoid speculative features ("this might be useful someday")</li>
    <li>Start with the minimal viable implementation</li>
    <li>Add complexity only when real use cases demand it</li>
    <li>Prefer composition over configuration</li>
  </ul>
</div>

<Guideline type="do">
  Build the exact feature requested. If a Button is needed with primary and
  secondary variants, implement only those two variants.
</Guideline>

<Guideline type="dont">
  Add extra variants, sizes, or props "just in case" — you can always add them
  later when a real need arises.
</Guideline>

---

## Accessibility

Building accessible components is essential for the Zen Design System. Every component must be usable by everyone, including people who rely on assistive technologies.

### Focus Management

- All interactive elements must be focusable
- Use `:focus-visible` for keyboard focus states (not `:focus`)
- Ensure focus order follows a logical reading sequence
- Trap focus within modals and dialogs when open

```css
.zen-component:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--color-focus-ring);
}
```

### Keyboard Navigation

- Support expected keyboard interactions for each component type
- Buttons: `Enter` and `Space` to activate
- Menus: Arrow keys to navigate, `Escape` to close
- Tabs: Arrow keys to switch, `Tab` to move focus
- Document all keyboard shortcuts in stories

### ARIA Attributes

Use ARIA attributes to enhance semantic meaning:

```tsx
// Button with loading state
<button aria-busy={loading} aria-disabled={disabled}>
  {loading ? 'Loading...' : children}
</button>

// Expandable section
<button aria-expanded={isOpen} aria-controls="panel-id">
  Toggle Panel
</button>
```

### Color Contrast

- Text must meet WCAG 2.1 AA contrast ratios (4.5:1 for normal text, 3:1 for large text)
- Use design tokens that have been verified for accessibility
- Never rely on color alone to convey information

### Testing with a11y Addon

The Storybook a11y addon is configured to automatically audit components. Check the "Accessibility" tab in Storybook to verify your component passes all checks:

- No violations should appear in the accessibility panel
- Test with keyboard-only navigation
- Verify screen reader announcements are meaningful

---

## Component Implementation

### TypeScript & Props

Define explicit types for all prop options using union types, and create a dedicated
props interface that extends native HTML attributes.

```tsx
import { HTMLAttributes, forwardRef } from 'react'
import './ComponentName.css'

export type ComponentVariant = 'primary' | 'secondary' | 'outline'
export type ComponentSize = 'sm' | 'md' | 'lg'

export interface ComponentNameProps extends HTMLAttributes<HTMLDivElement> {
  /** The visual style variant */
  variant?: ComponentVariant
  /** The size of the component */
  size?: ComponentSize
}
```

### Using forwardRef

Always use `forwardRef` to allow consumers to access the underlying DOM element:

```tsx
export const ComponentName = forwardRef<HTMLDivElement, ComponentNameProps>(
  (
    { variant = 'primary', size = 'md', className = '', children, ...props },
    ref,
  ) => {
    // Implementation
  },
)

ComponentName.displayName = 'ComponentName'
```

### CSS Class Construction

Build class names systematically using a consistent pattern:

```tsx
const classNames = [
  'zen-component',
  `zen-component--${variant}`,
  `zen-component--${size}`,
  className,
]
  .filter(Boolean)
  .join(' ')
```

---

## Naming Conventions

### Props

<div
  style={{
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
    gap: '1rem',
    marginBottom: '1.5rem',
  }}
>
  <div>
    <Guideline type="do">
      Use `variant` for visual style options (primary, secondary, outline,
      ghost)
    </Guideline>
    <Guideline type="do">
      Use `size` for dimension options (sm, md, lg)
    </Guideline>
    <Guideline type="do">
      Use boolean props for binary states: `disabled`, `loading`, `selected`
    </Guideline>
    <Guideline type="do">
      Use JSDoc comments with `/** */` to document each prop
    </Guideline>
  </div>
  <div>
    <Guideline type="dont">
      Use `type` or `style` for variants (conflicts with native attributes)
    </Guideline>
    <Guideline type="dont">Abbreviate prop names: `var`, `sz`, `dis`</Guideline>
    <Guideline type="dont">
      Use negative booleans: `notDisabled`, `isNotLoading`
    </Guideline>
    <Guideline type="dont">Create props for single-use edge cases</Guideline>
  </div>
</div>

### Common Prop Patterns

<table
  style={{
    width: '100%',
    borderCollapse: 'collapse',
    fontSize: 'var(--font-size-sm)',
  }}
>
  <thead>
    <tr style={{ borderBottom: '2px solid var(--color-border)' }}>
      <th
        style={{
          textAlign: 'left',
          padding: '0.75rem',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Prop
      </th>
      <th
        style={{
          textAlign: 'left',
          padding: '0.75rem',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Type
      </th>
      <th
        style={{
          textAlign: 'left',
          padding: '0.75rem',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Purpose
      </th>
    </tr>
  </thead>
  <tbody>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>variant</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Union type
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Visual style (primary, secondary, outline, ghost)
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>size</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>'sm' | 'md' | 'lg'</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Component dimensions
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>disabled</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Disables interaction
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>loading</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Shows loading state
      </td>
    </tr>
    <tr style={{ borderBottom: '1px solid var(--color-border-subtle)' }}>
      <td style={{ padding: '0.75rem' }}>
        <code>selected</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Indicates selection
      </td>
    </tr>
    <tr>
      <td style={{ padding: '0.75rem' }}>
        <code>fullWidth</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        <code>boolean</code>
      </td>
      <td style={{ padding: '0.75rem', color: 'var(--color-text-secondary)' }}>
        Expands to container width
      </td>
    </tr>
  </tbody>
</table>

### CSS Classes

- **Prefix all classes** with `zen-` to prevent collisions
- Use **BEM-style modifiers** with double dashes: `zen-component--variant`
- Keep class names **lowercase with hyphens**: `zen-card-header`

```css
.zen-component {
  /* Base styles */
}
.zen-component--primary {
  /* Variant styles */
}
.zen-component--sm {
  /* Size styles */
}
```

---

## Styling Guidelines

### Use Design Tokens

Always use CSS custom properties from the design system. Never use hardcoded values.

<Guideline type="do">

```css
.zen-component {
  padding: var(--space-3) var(--space-4);
  font-size: var(--font-size-base);
  border-radius: var(--radius-md);
  color: var(--color-text-primary);
}
```

</Guideline>

<Guideline type="dont">

```css
.zen-component {
  padding: 12px 16px;
  font-size: 16px;
  border-radius: 8px;
  color: #333333;
}
```

</Guideline>

### CSS File Organization

Structure your CSS file with clear sections:

```css
/* ============================================
   COMPONENT NAME
   ============================================ */

.zen-component {
  /* Reset */
  /* Layout */
  /* Typography */
  /* Shape */
  /* Interaction */
}

/* ----------------------------------------
   SIZE VARIANTS
   ---------------------------------------- */

.zen-component--sm {
}
.zen-component--md {
}
.zen-component--lg {
}

/* ----------------------------------------
   STYLE VARIANTS
   ---------------------------------------- */

.zen-component--primary {
}
.zen-component--secondary {
}
```

### Component-Level CSS Variables

Define component-specific CSS custom properties to enable easy customization and maintain consistency across size variants:

```css
.zen-button--md {
  --button-height: 2.5rem;
  --button-padding-x: var(--space-4);
  --button-font-size: var(--font-size-base);

  height: var(--button-height);
  padding: 0 var(--button-padding-x);
  font-size: var(--button-font-size);
}
```

This pattern allows consumers to override specific values without modifying the base styles, and makes the relationship between size variants explicit and maintainable.

<Guideline type="do">
  Define component-level variables for dimensions, spacing, and typography that
  vary by size or variant.
</Guideline>

<Guideline type="dont">
  Use magic numbers directly in property values — always reference a design
  token or component variable.
</Guideline>

### Interactive States

Always define states in this order:

1. Base styles
2. `:hover:not(:disabled)`
3. `:focus-visible`
4. `:active:not(:disabled)`
5. `:disabled`

```css
.zen-component {
  transition: background-color var(--transition-fast), color var(--transition-fast),
    border-color var(--transition-fast);
}

.zen-component:focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--color-focus-ring);
}

.zen-component:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}
```

---

## Responsive Props

Zen Design supports responsive props, allowing any visual prop to accept different values at different breakpoints. This enables components to adapt seamlessly to different screen sizes without writing custom CSS.

### Understanding Responsive Props

Every prop type `T` can be extended to accept `T | { base?: T, xs?: T, sm?: T, md?: T, lg?: T }`:

```tsx
// Simple value (applies to all breakpoints)
<Box padding="md" />

// Responsive object (different values per breakpoint)
<Box padding={{ base: 'xs', sm: 'md', lg: 'xl' }} />
```

See the [Breakpoints documentation](/docs/foundations-breakpoints--docs) for complete details on the breakpoint system.

### Making Props Responsive

To make a prop responsive, use the `Responsive<T>` type:

```tsx
import type { Responsive } from '../../utils/Responsive'

export interface ComponentNameProps extends HTMLAttributes<HTMLDivElement> {
  /** Padding that adapts to screen size */
  padding?: Responsive<'xs' | 'sm' | 'md' | 'lg' | 'xl'>
  /** Gap between items */
  gap?: Responsive<string>
}
```

### Implementation Pattern

Follow this pattern to implement responsive props:

#### 1. Import Required Utilities

```tsx
import type { Responsive, ResponsiveObject } from '../../utils/Responsive'
import { isResponsiveObject } from '../../utils/Responsive'
import { processResponsiveProps } from '../../utils/responsiveProps'
```

#### 2. Normalize Values (if needed)

If your prop accepts a union type that needs conversion to CSS values, create a normalization function:

```tsx
type ComponentGap = 'none' | 'xs' | 'sm' | 'md' | 'lg'

function gapToCSS(gap: ComponentGap): string {
  const mapping: Record<ComponentGap, string> = {
    none: '0',
    xs: 'var(--space-1)',
    sm: 'var(--space-2)',
    md: 'var(--space-4)',
    lg: 'var(--space-6)',
  }
  return mapping[gap]
}

function normalizeResponsiveGap(
  value: Responsive<ComponentGap> | undefined,
): Responsive<string> | undefined {
  if (value === undefined) return undefined

  if (isResponsiveObject(value)) {
    const normalized: ResponsiveObject<string> = {}
    if (value.base !== undefined) normalized.base = gapToCSS(value.base)
    if (value.xs !== undefined) normalized.xs = gapToCSS(value.xs)
    if (value.sm !== undefined) normalized.sm = gapToCSS(value.sm)
    if (value.md !== undefined) normalized.md = gapToCSS(value.md)
    if (value.lg !== undefined) normalized.lg = gapToCSS(value.lg)
    return normalized
  }

  return gapToCSS(value)
}
```

#### 3. Process Responsive Props

In your component, process responsive props and generate CSS custom properties:

```tsx
export const ComponentName = forwardRef<HTMLDivElement, ComponentNameProps>(
  ({ padding, gap, className = '', style, children, ...props }, ref) => {
    // Process responsive props to CSS custom properties
    const responsiveStyles = processResponsiveProps('component', {
      padding: normalizeResponsivePadding(padding),
      gap: normalizeResponsiveGap(gap),
    })

    // Add data attributes to enable CSS rules conditionally
    const dataAttributes: Record<string, string> = {}
    if (padding && isResponsiveObject(padding)) {
      dataAttributes['data-has-responsive-padding'] = 'true'
    }
    if (gap && isResponsiveObject(gap)) {
      dataAttributes['data-has-responsive-gap'] = 'true'
    }

    return (
      <div
        ref={ref}
        className={className}
        style={{ ...responsiveStyles, ...style }}
        {...dataAttributes}
        {...props}
      >
        {children}
      </div>
    )
  },
)
```

#### 4. Add CSS with Media Queries

Create CSS rules that use CSS custom properties with fallback chains:

```css
/* Responsive padding */
/* Only applies when data-has-responsive-padding attribute is present */
.component[data-has-responsive-padding='true'] {
  padding: var(--component-padding-base);
}

@media (min-width: 480px) {
  /* --breakpoint-xs: 480px */
  .component[data-has-responsive-padding='true'] {
    padding: var(--component-padding-xs, var(--component-padding-base));
  }
}

@media (min-width: 640px) {
  /* --breakpoint-sm: 640px */
  .component[data-has-responsive-padding='true'] {
    padding: var(
      --component-padding-sm,
      var(--component-padding-xs, var(--component-padding-base))
    );
  }
}

@media (min-width: 1024px) {
  /* --breakpoint-md: 1024px */
  .component[data-has-responsive-padding='true'] {
    padding: var(
      --component-padding-md,
      var(
        --component-padding-sm,
        var(--component-padding-xs, var(--component-padding-base))
      )
    );
  }
}

@media (min-width: 1280px) {
  /* --breakpoint-lg: 1280px */
  .component[data-has-responsive-padding='true'] {
    padding: var(
      --component-padding-lg,
      var(
        --component-padding-md,
        var(
          --component-padding-sm,
          var(--component-padding-xs, var(--component-padding-base))
        )
      )
    );
  }
}
```

### Key Implementation Details

**1. Data Attributes**

Always add data attributes when responsive props are used. This ensures CSS rules only apply when the CSS custom properties actually exist, preventing undefined variable warnings:

```tsx
if (padding && isResponsiveObject(padding)) {
  dataAttributes['data-has-responsive-padding'] = 'true'
}
```

**2. CSS Custom Property Naming**

CSS custom properties follow this pattern:

```
--{componentName}-{propName}-{breakpoint}
```

Examples:

- `--box-padding-base`
- `--flex-gap-sm`
- `--grid-columns-lg`

**3. Fallback Chains**

Use nested `var()` functions to create fallback chains that inherit from smaller breakpoints:

```css
/* At sm breakpoint, try sm first, then xs, then base */
padding: var(
  --component-padding-sm,
  var(--component-padding-xs, var(--component-padding-base))
);
```

**4. Component Name Parameter**

The first parameter to `processResponsiveProps` should be the component name (lowercase, no hyphens):

```tsx
processResponsiveProps('box', { padding: ... })      // ✅ Correct
processResponsiveProps('zen-box', { padding: ... })  // ❌ Wrong
processResponsiveProps('Box', { padding: ... })      // ❌ Wrong
```

### Backward Compatibility

Responsive props maintain backward compatibility with simple values. If a user passes a simple value, it works exactly as before:

```tsx
// Both work identically for non-responsive usage
<Box padding="md" />
<Box padding={{ base: 'md' }} />
```

### Best Practices

<Guideline type="do">
  Make layout and spacing props responsive (padding, margin, gap, columns, etc.)
</Guideline>

<Guideline type="do">
  Use data attributes to conditionally apply CSS rules
</Guideline>

<Guideline type="do">
  Add comments in CSS referencing breakpoint tokens
</Guideline>

<Guideline type="dont">
  Make event handlers, refs, or children responsive
</Guideline>

<Guideline type="dont">
  Create responsive props for props that don't benefit from breakpoint changes
</Guideline>

---

## Storybook Stories

### File Structure

```tsx
import type { Meta, StoryObj } from '@storybook/react'
import { ComponentName } from './ComponentName'

const meta: Meta<typeof ComponentName> = {
  title: 'Components/ComponentName',
  component: ComponentName,
  tags: ['autodocs'],
  parameters: {
    layout: 'fullscreen',
  },
  argTypes: {
    // Define controls for each prop
  },
}

export default meta
type Story = StoryObj<typeof ComponentName>
```

### Configuring ArgTypes

Provide meaningful controls and descriptions for each prop:

```tsx
argTypes: {
  variant: {
    control: 'select',
    options: ['primary', 'secondary', 'outline', 'ghost'],
    description: 'The visual style variant',
  },
  size: {
    control: 'select',
    options: ['sm', 'md', 'lg'],
    description: 'The size of the component',
  },
  disabled: {
    control: 'boolean',
    description: 'Whether the component is disabled',
  },
}
```

---

## Story Granularity

Stories should be **comprehensive but focused**. Each story should demonstrate
a specific aspect of the component.

### Playground Story (Required)

Every component **must** include a `Playground` story as the first story. This provides an interactive sandbox where developers can experiment with all props using Storybook controls.

```tsx
export const Playground: Story = {
  args: {
    children: 'Button',
    variant: 'primary',
    size: 'md',
    disabled: false,
  },
}
```

The Playground story should:

- Be the first exported story (appears at the top of the component's story list)
- Include sensible default values for all props via `args`
- Enable full interactivity through Storybook's Controls panel

### Using Design Tokens in Stories

Always use design tokens instead of hardcoded pixel or rem values in story layouts. This ensures visual consistency with the design system.

<Guideline type="do">

```tsx
<div style={{ display: 'flex', gap: 'var(--space-4)', alignItems: 'center' }}>
  <Button variant="primary">Primary</Button>
  <Button variant="secondary">Secondary</Button>
</div>
```

</Guideline>

<Guideline type="dont">

```tsx
<div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
  <Button variant="primary">Primary</Button>
  <Button variant="secondary">Secondary</Button>
</div>
```

</Guideline>

### Required Stories

Every component should include these essential stories:

<div
  style={{
    padding: '1.5rem',
    backgroundColor: 'var(--color-surface)',
    border: '1px solid var(--color-border-subtle)',
    borderRadius: 'var(--radius-md)',
    marginBottom: '1.5rem',
  }}
>
  <h4
    style={{
      margin: '0 0 1rem 0',
      fontSize: 'var(--font-size-base)',
      fontWeight: 'var(--font-weight-semibold)',
      color: 'var(--color-text-primary)',
    }}
  >
    Essential Stories Checklist
  </h4>
  <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>Playground</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Interactive sandbox with all props via args
      </span>
    </div>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>All Variants</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Shows each variant side by side
      </span>
    </div>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>All Sizes</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Shows each size side by side
      </span>
    </div>
    <div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
      <span style={{ color: 'var(--color-secondary-500)' }}>✓</span>
      <strong>Disabled State</strong>
      <span
        style={{
          color: 'var(--color-text-muted)',
          fontSize: 'var(--font-size-sm)',
        }}
      >
        — Shows disabled state for each variant
      </span>
    </div>
  </div>
</div>

### Story Patterns

#### Composite Stories (Preferred for Visual Comparison)

Show multiple variations in a single story for easy visual comparison:

```tsx
export const AllVariants: Story = {
  name: 'All Variants',
  render: () => (
    <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
      <ComponentName variant="primary">Primary</ComponentName>
      <ComponentName variant="secondary">Secondary</ComponentName>
      <ComponentName variant="outline">Outline</ComponentName>
    </div>
  ),
}
```

#### State Stories

Group related states together:

```tsx
export const Disabled: Story = {
  render: () => (
    <div style={{ display: 'flex', gap: '1rem', alignItems: 'center' }}>
      <ComponentName variant="primary" disabled>
        Primary
      </ComponentName>
      <ComponentName variant="secondary" disabled>
        Secondary
      </ComponentName>
      <ComponentName variant="outline" disabled>
        Outline
      </ComponentName>
    </div>
  ),
}
```

### When to Create Separate Stories

Create individual stories for:

- **Complex interactions** that need isolated testing
- **Edge cases** like very long content or unusual states
- **Responsive behavior** that needs viewport controls
- **Integration examples** showing component combinations

### Story Naming

Use clear, descriptive names with the `name` property:

```tsx
export const AllVariants: Story = {
  name: 'All Variants',
  // ...
}

export const WithLongContent: Story = {
  name: 'With Long Content',
  // ...
}
```

---

## Barrel Exports

The `index.ts` file should export the component and all its types:

```tsx
export { ComponentName } from './ComponentName'
export type {
  ComponentNameProps,
  ComponentVariant,
  ComponentSize,
} from './ComponentName'
```

---

## Checklist

Before submitting a new component, verify:

<div
  style={{
    padding: '1.5rem',
    backgroundColor: 'var(--color-surface)',
    border: '1px solid var(--color-border-subtle)',
    borderRadius: 'var(--radius-md)',
  }}
>
  <div
    style={{
      display: 'grid',
      gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
      gap: '1rem',
    }}
  >
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Implementation
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Uses <code>forwardRef</code> for DOM access
        </li>
        <li>Extends appropriate native HTML attributes</li>
        <li>Has JSDoc comments on all props</li>
        <li>
          Sets <code>displayName</code> for debugging
        </li>
        <li>Provides sensible default prop values</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Styling
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>Uses only design tokens (no hardcoded values)</li>
        <li>
          Has <code>zen-</code> prefix on all classes
        </li>
        <li>Defines all interactive states</li>
        <li>Includes focus-visible styles</li>
        <li>Has disabled state with proper cursor</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Storybook
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Has <code>Playground</code> story as first story
        </li>
        <li>
          Has <code>autodocs</code> tag enabled
        </li>
        <li>Includes stories for all variants</li>
        <li>Includes stories for all sizes</li>
        <li>Shows disabled states</li>
        <li>Uses design tokens in story layouts</li>
        <li>
          Has descriptive <code>argTypes</code>
        </li>
        <li>Passes a11y addon checks</li>
      </ul>
    </div>
    <div>
      <h4
        style={{
          margin: '0 0 0.75rem 0',
          fontSize: 'var(--font-size-sm)',
          fontWeight: 'var(--font-weight-semibold)',
          color: 'var(--color-text-primary)',
        }}
      >
        Exports
      </h4>
      <ul
        style={{
          margin: 0,
          paddingLeft: '1.25rem',
          fontSize: 'var(--font-size-sm)',
          color: 'var(--color-text-secondary)',
          lineHeight: '1.8',
        }}
      >
        <li>
          Has barrel export in <code>index.ts</code>
        </li>
        <li>Exports component and all types</li>
        <li>Added to main library exports</li>
      </ul>
    </div>
  </div>
</div>
